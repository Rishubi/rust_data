{"wrong_code": "// variables1.rs\n// Make me compile!\n// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    x = 5;\n    println!(\"x has the value {}\", x);\n}\n", "error": "error[E0425]: cannot find value `x` in this scope\n --> exercises/variables/variables1.rs:8:5\n  |\n8 |     x = 5;\n  |     ^ not found in this scope\n\nerror[E0425]: cannot find value `x` in this scope\n --> exercises/variables/variables1.rs:9:36\n  |\n9 |     println!(\"x has the value {}\", x);\n  |                                    ^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// variables1.rs\n// Make me compile!\n// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x = 5;\n    println!(\"x has the value {}\", x);\n}\n"}

{"wrong_code": "// variables2.rs\n// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let x;\n    if x == 10 {\n        println!(\"x is ten!\");\n    } else {\n        println!(\"x is not ten!\");\n    }\n}\n", "error": "error[E0282]: type annotations needed\n --> exercises/variables/variables2.rs:7:9\n  |\n7 |     let x;\n  |         ^\n  |\nhelp: consider giving `x` an explicit type\n  |\n7 |     let x: _;\n  |          +++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// variables2.rs\n// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x=10;\n    if x == 10 {\n        println!(\"x is ten!\");\n    } else {\n        println!(\"x is not ten!\");\n    }\n}\n"}

{"wrong_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let x: i32;\n    println!(\"Number {}\", x);\n}\n", "error": "error[E0381]: used binding `x` isn't initialized\n --> exercises/variables/variables3.rs:8:27\n  |\n7 |     let x: i32;\n  |         - binding declared here but left uninitialized\n8 |     println!(\"Number {}\", x);\n  |                           ^ `x` used here but it isn't initialized\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0381`.\n", "right_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x: i32=1;\n    println!(\"Number {}\", x);\n}\n"}
{"wrong_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x: i32=1-;\n    println!(\"Number {}\", x);\n}\n", "error": "error: expected expression, found `;`\n --> exercises/variables/variables3.rs:7:18\n  |\n7 |     let x: i32=1-;\n  |                  ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x: i32=1;\n    println!(\"Number {}\", x);\n}\n"}

{"wrong_code": "// variables4.rs\n// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let x = 3;\n    println!(\"Number {}\", x);\n    x = 5; // don't change this line\n    println!(\"Number {}\", x);\n}\n", "error": "error[E0384]: cannot assign twice to immutable variable `x`\n --> exercises/variables/variables4.rs:9:5\n  |\n7 |     let x = 3;\n  |         -\n  |         |\n  |         first assignment to `x`\n  |         help: consider making this binding mutable: `mut x`\n8 |     println!(\"Number {}\", x);\n9 |     x = 5; // don't change this line\n  |     ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n", "right_code": "// variables4.rs\n// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let mut x = 3;\n    println!(\"Number {}\", x);\n    x = 5; // don't change this line\n    println!(\"Number {}\", x);\n}\n"}

{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n", "error": "error[E0425]: cannot find function `call_me` in this scope\n --> exercises/functions/functions1.rs:7:5\n  |\n7 |     call_me();\n  |     ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_m", "error": "error: expected one of `(` or `<`, found `<eof>`\n  --> exercises/functions/functions1.rs:10:4\n   |\n10 | fn call_m\n   |    ^^^^^^ expected one of `(` or `<`\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    ", "error": "error: this file contains an unclosed delimiter\n  --> exercises/functions/functions1.rs:11:5\n   |\n10 | fn call_me() { \n   |              - unclosed delimiter\n11 |     \n   |     ^\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!()", "error": "error: this file contains an unclosed delimiter\n  --> exercises/functions/functions1.rs:11:15\n   |\n10 | fn call_me() { \n   |              - unclosed delimiter\n11 |     println!()\n   |               ^\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(hello\")", "error": "error[E0765]: unterminated double quote string\n  --> exercises/functions/functions1.rs:11:19\n   |\n11 |     println!(hello\")\n   |                   ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")", "error": "error: this file contains an unclosed delimiter\n  --> exercises/functions/functions1.rs:11:22\n   |\n10 | fn call_me() { \n   |              - unclosed delimiter\n11 |     println!(\"hello\")\n   |                      ^\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}

{"wrong_code": "// functions2.rs\n// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n", "error": "error: expected type, found `)`\n  --> exercises/functions/functions2.rs:10:16\n   |\n10 | fn call_me(num:) {\n   |                ^ expected type\n\nerror[E0425]: cannot find value `num` in this scope\n  --> exercises/functions/functions2.rs:11:17\n   |\n11 |     for i in 0..num {\n   |                 ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// functions2.rs\n// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:i32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n"}

{"wrong_code": "// functions3.rs\n// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n\nfn call_me(num: u32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n", "error": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n  --> exercises/functions/functions3.rs:7:5\n   |\n7  |     call_me();\n   |     ^^^^^^^-- an argument of type `u32` is missing\n   |\nnote: function defined here\n  --> exercises/functions/functions3.rs:10:4\n   |\n10 | fn call_me(num: u32) {\n   |    ^^^^^^^ --------\nhelp: provide the argument\n   |\n7  |     call_me(/* u32 */);\n   |            ~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// functions3.rs\n// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num: u32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n"}

{"wrong_code": "// functions4.rs\n// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.\n\n// This store is having a sale where if the price is an even number, you get\n// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n// I AM NOT DONE\n\nfn main() {\n    let original_price = 51;\n    println!(\"Your sale price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: i32) -> {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: i32) -> bool {\n    num % 2 == 0\n}\n", "error": "error: expected type, found `{`\n  --> exercises/functions/functions4.rs:17:30\n   |\n17 | fn sale_price(price: i32) -> {\n   |                              ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// functions4.rs\n// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.\n\n// This store is having a sale where if the price is an even number, you get\n// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\nfn main() {\n    let original_price = 51;\n    println!(\"Your sale price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: i32) -> i32{\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: i32) -> bool {\n    num % 2 == 0\n}\n"}

{"wrong_code": "// functions5.rs\n// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let answer = square(3);\n    println!(\"The square of 3 is {}\", answer);\n}\n\nfn square(num: i32) -> i32 {\n    num * num;\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/functions/functions5.rs:11:24\n   |\n11 | fn square(num: i32) -> i32 {\n   |    ------              ^^^ expected `i32`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n12 |     num * num;\n   |              - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// functions5.rs\n// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = square(3);\n    println!(\"The square of 3 is {}\", answer);\n}\n\nfn square(num: i32) -> i32 {\n    num * num\n}\n"}

{"wrong_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn bigger(a: i32, b: i32) -> i32 {\n    // Complete this function to return the bigger number!\n    // Do not use:\n    // - another function call\n    // - additional variables\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n", "error": "error[E0308]: mismatched types\n --> exercises/if/if1.rs:6:34\n  |\n6 | pub fn bigger(a: i32, b: i32) -> i32 {\n  |        ------                    ^^^ expected `i32`, found `()`\n  |        |\n  |        implicitly returns `()` as its body has no tail or `return` expression\n  |\nnote: consider returning one of these bindings\n --> exercises/if/if1.rs:6:15\n  |\n6 | pub fn bigger(a: i32, b: i32) -> i32 {\n  |               ^       ^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n   else \n   {\n    b\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n"}
{"wrong_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n", "error": "error: expected `{`, found `}`\n --> exercises/if/if1.rs:8:1\n  |\n8 | }\n  | ^ expected `{`\n  |\nnote: the `if` expression is missing a block after this condition\n --> exercises/if/if1.rs:7:7\n  |\n7 |    if a\n  |       ^\n\nerror: aborting due to previous error\n\n", "right_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n   else \n   {\n    b\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n"}
{"wrong_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n", "error": "error[E0317]: `if` may be missing an `else` clause\n --> exercises/if/if1.rs:7:4\n  |\n6 |   pub fn bigger(a: i32, b: i32) -> i32 {\n  |                                    --- expected `i32` because of this return type\n7 | /    if a>b {\n8 | |     a\n9 | |    }\n  | |____^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0317`.\n", "right_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n   else \n   {\n    b\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n"}

{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else {\n        1\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/if/if2.rs:13:9\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                      ---- expected `&str` because of return type\n...\n13 |         1\n   |         ^ expected `&str`, found integer\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if{\n        1\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: missing condition for `if` expression\n  --> exercises/if/if2.rs:12:14\n   |\n12 |     } else if{\n   |              ^\n   |              |\n   |              expected condition here\n   |              if this block is the condition of the `if` expression, then it must be followed by another block\n\nerror[E0308]: mismatched types\n  --> exercises/if/if2.rs:13:9\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                      ---- expected `&str` because of return type\n...\n13 |         1\n   |         ^ expected `&str`, found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz(\"literally anything\n        1\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/if/if2.rs:34:59\n   |\n34 |           assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n   |  ___________________________________________________________^\n35 | |     }\n36 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz(\"literally anything\n        \n    foo_if_fizz(\"fuzz\")\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/if/if2.rs:35:59\n   |\n35 |           assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n   |  ___________________________________________________________^\n36 | |     }\n37 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz(\"literally anything\n        \n    else if fizzish=\"fuzz\"{\n        \n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/if/if2.rs:37:59\n   |\n37 |           assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n   |  ___________________________________________________________^\n38 | |     }\n39 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=literally anything\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:18:1\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n17 |     }\n   |     - ...matches this closing brace\n18 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \n    }\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:21:1\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n20 |     }\n   |     - ...matches this closing brace\n21 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } else {\n        &fizzish\n    }\n}\n\n    }\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:20:5\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n18 | }\n   | - ...matches this closing brace\n19 |\n20 |     }\n   |     ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } \n}\n\n    }\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:18:5\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n16 | }\n   | - ...matches this closing brace\n17 |\n18 |     }\n   |     ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n}\n\n    }\n        \n   \n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:21:5\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n19 | }\n   | - ...matches this closing brace\n20 |\n21 |     }\n   |     ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz=\"literally anything\"\n   |               ^^^^ not found in this scope\n   |\nhelp: you might have meant to use pattern matching\n   |\n12 |     } else if let fizz=\"literally anything\"\n   |               +++\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> exercises/if/if2.rs:16:10\n   |\n16 |       else if fizzish==\"fuzz\" {\n   |  __________^\n17 | |         \"foo\"\n   | |         ----- found here\n18 | |     }\n   | |_____^ expected `()`, found `&str`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"baz\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz=\"literally anything\"\n   |               ^^^^ not found in this scope\n   |\nhelp: you might have meant to use pattern matching\n   |\n12 |     } else if let fizz=\"literally anything\"\n   |               +++\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> exercises/if/if2.rs:16:10\n   |\n16 |       else if fizzish==\"fuzz\" {\n   |  __________^\n17 | |         \"bar\"\n   | |         ----- found here\n18 | |     }\n   | |_____^ expected `()`, found `&str`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz==\"literally anything\"\n   |               ^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> exercises/if/if2.rs:16:10\n   |\n16 |       else if fizzish==\"fuzz\" {\n   |  __________^\n17 | |         \"bar\"\n   | |         ----- found here\n18 | |     }\n   | |_____^ expected `()`, found `&str`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz==\"literally anything\"\n   |               ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}

{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\n", "error": "error[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:21:18\n   |\n21 |     let price1 = calculate_price_of_apples(35);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:22:18\n   |\n22 |     let price2 = calculate_price_of_apples(40);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:23:18\n   |\n23 |     let price3 = calculate_price_of_apples(41);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:24:18\n   |\n24 |     let price4 = calculate_price_of_apples(65);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(35)", "error": "error: expected one of `...`, `..=`, `..`, `:`, or `|`, found `)`\n  --> exercises/quiz1.rs:31:32\n   |\n31 | fn calculate_price_of_apples(35)\n   |                                ^ expected one of `...`, `..=`, `..`, `:`, or `|`\n\nerror: expected one of `->`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:32\n   |\n31 | fn calculate_price_of_apples(35)\n   |                                ^ expected one of `->`, `where`, or `{`\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples()", "error": "error: expected one of `->`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:30\n   |\n31 | fn calculate_price_of_apples()\n   |                              ^ expected one of `->`, `where`, or `{`\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)", "error": "error: expected one of `->`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:35\n   |\n31 | fn calculate_price_of_apples(a:i32)\n   |                                   ^ expected one of `->`, `where`, or `{`\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32", "error": "error: expected one of `!`, `(`, `+`, `::`, `<`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:38\n   |\n31 | fn calculate_price_of_apples(a:i32)->i32\n   |                                      ^^^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    \n}", "error": "error[E0308]: mismatched types\n  --> exercises/quiz1.rs:31:38\n   |\n31 | fn calculate_price_of_apples(a:i32)->i32{\n   |    -------------------------         ^^^ expected `i32`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\nhelp: consider returning the local binding `a`\n   |\n31 ~ fn calculate_price_of_apples(a:i32)->i32{\n32 +     a\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a\n}", "error": "error: expected `{`, found `}`\n  --> exercises/quiz1.rs:32:1\n   |\n32 | }\n   | ^ expected `{`\n   |\nnote: the `if` expression is missing a block after this condition\n  --> exercises/quiz1.rs:31:8\n   |\n31 |     if a\n   |        ^\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40\n}", "error": "error: expected `{`, found `}`\n  --> exercises/quiz1.rs:32:1\n   |\n32 | }\n   | ^ expected `{`\n   |\nnote: the `if` expression is missing a block after this condition\n  --> exercises/quiz1.rs:31:8\n   |\n31 |     if a>40\n   |        ^^^^\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n}", "error": "error[E0317]: `if` may be missing an `else` clause\n  --> exercises/quiz1.rs:31:5\n   |\n30 |   fn calculate_price_of_apples(a:i32)->i32{\n   |                                        --- expected `i32` because of this return type\n31 | /     if a>40{\n32 | |         a\n33 | |     }\n   | |_____^ expected `i32`, found `()`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0317`.\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n}", "error": "error: expected `{`, found `}`\n  --> exercises/quiz1.rs:35:1\n   |\n35 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}

{"wrong_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let // Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n", "error": "error: expected identifier, found keyword `if`\n  --> exercises/primitive_types/primitive_types1.rs:16:5\n   |\n16 |     if is_evening {\n   |     ^^ expected identifier, found keyword\n\nerror: expected one of `:`, `;`, `=`, `@`, or `|`, found `is_evening`\n  --> exercises/primitive_types/primitive_types1.rs:16:8\n   |\n16 |     if is_evening {\n   |        ^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening=true;// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n", "error": "error: expected `;`, found keyword `if`\n  --> exercises/primitive_types/primitive_types1.rs:15:19\n   |\n15 |     let is_evening// Finish the rest of this line like the example! Or make it be false!\n   |                   ^ help: add `;` here\n16 |     if is_evening {\n   |     -- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening=true;// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n"}

{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error: expected identifier, found keyword `if`\n  --> exercises/primitive_types/primitive_types2.rs:24:5\n   |\n24 |     if your_character.is_alphabetic() {\n   |     ^^ expected identifier, found keyword\n\nerror: expected one of `:`, `;`, `=`, `@`, or `|`, found `your_character`\n  --> exercises/primitive_types/primitive_types2.rs:24:8\n   |\n24 |     if your_character.is_alphabetic() {\n   |        ^^^^^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=// Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/primitive_types/primitive_types2.rs:30:6\n   |\n30 |     }\n   |      ^ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `your_character` in this scope\n  --> exercises/primitive_types/primitive_types2.rs:24:8\n   |\n24 |     if your_character.is_alphabetic() {\n   |        ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `your_character` in this scope\n  --> exercises/primitive_types/primitive_types2.rs:26:15\n   |\n26 |     } else if your_character.is_numeric() {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=1 // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error: expected `;`, found keyword `if`\n  --> exercises/primitive_types/primitive_types2.rs:21:25\n   |\n21 |     let your_character=1 // Finish this line like the example! What's your favorite character?\n   |                         ^ help: add `;` here\n...\n24 |     if your_character.is_alphabetic() {\n   |     -- unexpected token\n\nerror[E0599]: no method named `is_alphabetic` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:24:23\n   |\n24 |     if your_character.is_alphabetic() {\n   |                       ^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_numeric` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:26:30\n   |\n26 |     } else if your_character.is_numeric() {\n   |                              ^^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=1 ;// Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error[E0599]: no method named `is_alphabetic` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:24:23\n   |\n24 |     if your_character.is_alphabetic() {\n   |                       ^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_numeric` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:26:30\n   |\n26 |     } else if your_character.is_numeric() {\n   |                              ^^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=1 ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error[E0599]: no method named `is_alphabetic` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:25:23\n   |\n25 |     if your_character.is_alphabetic() {\n   |                       ^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_numeric` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:27:30\n   |\n27 |     } else if your_character.is_numeric() {\n   |                              ^^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=\" ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/primitive_types/primitive_types2.rs:30:50\n   |\n30 |           println!(\"Neither alphabetic nor numeric!\");\n   |  __________________________________________________^\n31 | |     }\n32 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}

{"wrong_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let a = ???\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n", "error": "error: expected expression, found `?`\n --> exercises/primitive_types/primitive_types3.rs:8:13\n  |\n8 |     let a = ???\n  |             ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let a = \"hhhh\";\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n"}
{"wrong_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let a = \"\"\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n", "error": "error: expected `;`, found keyword `if`\n  --> exercises/primitive_types/primitive_types3.rs:8:15\n   |\n8  |     let a = \"\"\n   |               ^ help: add `;` here\n9  |\n10 |     if a.len() >= 100 {\n   |     -- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let a = \"hhhh\";\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n"}

{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = ???\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/primitive_types/primitive_types4.rs:11:22\n   |\n11 |     let nice_slice = ???\n   |                      ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = ???\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/primitive_types/primitive_types4.rs:10:22\n   |\n10 |     let nice_slice = ???\n   |                      ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1]\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = a[1]\n   |                          ^ help: add `;` here\n11 |\n12 |     assert_eq!([2, 3, 4], nice_slice)\n   |     --------- unexpected token\n\nerror[E0277]: can't compare `[{integer}; 3]` with `{integer}`\n  --> exercises/primitive_types/primitive_types4.rs:12:5\n   |\n12 |     assert_eq!([2, 3, 4], nice_slice)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `[{integer}; 3] == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `[{integer}; 3]`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n           and 3 others\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[]\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected expression, found `]`\n  --> exercises/primitive_types/primitive_types4.rs:10:24\n   |\n10 |     let nice_slice = a[]\n   |                        ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3...5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[3...5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[3..5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[3..=5];\n   |                         ~~~\n\nerror[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[3...5];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[3...5];\n   |                      +\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3..5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[3..5];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[3..5];\n   |                      +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3.5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error[E0277]: the type `[{integer}]` cannot be indexed by `{float}`\n  --> exercises/primitive_types/primitive_types4.rs:10:24\n   |\n10 |     let nice_slice = a[3.5];\n   |                        ^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `{float}`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required for `[{integer}]` to implement `Index<{float}>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3....5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[3....5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[3...5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[3..=.5];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[3....5];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[3....5];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[2....5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[2....5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[2...5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[2..=.5];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[2....5];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[2....5];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1....5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1...5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=.5];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....5];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[1....5];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1....3];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....3];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1...3];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=.3];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....3];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[1....3];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1....4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....4];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1...4];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=.4];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....4];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[1....4];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1...4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1...4];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1..4];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=4];\n   |                         ~~~\n\nerror[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[1...4];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[1...4];\n   |                      +\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[1..4];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[1..4];\n   |                      +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1....4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = &a[1....4];\n   |                          ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = &a[1...4];\n   |                          ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = &a[1..=.4];\n   |                          ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = &a[1....4];\n   |                          ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:29\n   |\n10 |     let nice_slice = &a[1....4];\n   |                             ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1...4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = &a[1...4];\n   |                          ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = &a[1..4];\n   |                          ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = &a[1..=4];\n   |                          ~~~\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}

{"wrong_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let /* your pattern here */ = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n", "error": "error: expected pattern, found `=`\n --> exercises/primitive_types/primitive_types5.rs:9:33\n  |\n9 |     let /* your pattern here */ = cat;\n  |                                 ^ expected pattern\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let (name,age) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n"}
{"wrong_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let (name) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n", "error": "error[E0425]: cannot find value `age` in this scope\n  --> exercises/primitive_types/primitive_types5.rs:11:43\n   |\n11 |     println!(\"{} is {} years old.\", name, age);\n   |                                           ^^^ not found in this scope\n\nwarning: unnecessary parentheses around pattern\n --> exercises/primitive_types/primitive_types5.rs:9:9\n  |\n9 |     let (name) = cat;\n  |         ^    ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n9 -     let (name) = cat;\n9 +     let name = cat;\n  |\n\nerror[E0277]: `(&str, {float})` doesn't implement `std::fmt::Display`\n  --> exercises/primitive_types/primitive_types5.rs:11:37\n   |\n11 |     println!(\"{} is {} years old.\", name, age);\n   |                                     ^^^^ `(&str, {float})` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `(&str, {float})`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let (name,age) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n"}

{"wrong_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second = ???;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/primitive_types/primitive_types6.rs:12:18\n   |\n12 |     let second = ???;\n   |                  ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second =2;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n"}
{"wrong_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second =\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/primitive_types/primitive_types6.rs:15:52\n   |\n15 |         \"This is not the 2nd number in the tuple!\")\n   |                                                    ^ help: add `;` here\n16 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `second` in this scope\n  --> exercises/primitive_types/primitive_types6.rs:14:19\n   |\n14 |     assert_eq!(2, second,\n   |                   ^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second =2;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n"}

{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = // TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/vecs/vecs1.rs:13:11\n   |\n13 |     (a, v)\n   |           ^ help: add `;` here\n14 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v)\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\nhelp: consider returning the local binding `v`\n  |\n13~     (a, v)\n14+     v\n  |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = // TODO: declare your vector here with the macro for vectors\n\n    (a, v);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v);\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\nhelp: consider returning the local binding `v`\n  |\n13~     (a, v);\n14+     v\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec!// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/vecs/vecs1.rs:13:11\n   |\n13 |     (a, v)\n   |           ^ help: add `;` here\n14 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v)\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> exercises/vecs/vecs1.rs:14:1\n   |\n14 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/vecs/vecs1.rs:11:17\n   |\n9  | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n   |                                            - closing delimiter possibly meant for this\n10 |     let a = [10, 20, 30, 40]; // a plain array\n11 |     let v = vec![// TODO: declare your vector here with the macro for vectors\n   |                 ^ unclosed delimiter\n...\n14 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![1,2,3,4]// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/vecs/vecs1.rs:13:11\n   |\n13 |     (a, v)\n   |           ^ help: add `;` here\n14 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v)\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0618]: expected function, found `Vec<{integer}>`\n  --> exercises/vecs/vecs1.rs:11:13\n   |\n11 |       let v = vec![1,2,3,4]// TODO: declare your vector here with the macro for vectors\n   |               -^^^^^^^^^^^^\n   |               |\n   |  _____________help: consider using a semicolon here: `;`\n   | |\n12 | |\n13 | |     (a, v)\n   | |__________- call expression requires function\n   |\n   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\nhelp: consider returning the local binding `v`\n  |\n13~     (a, v)\n14+     v\n  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0618.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}

{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        ???\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         ???\n   |         ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        * i\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         * i\n   |         ^^^ expected `()`, found `i32`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*2\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         *i*2\n   |         ^^^^ expected `()`, found `i32`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         *i\n   |         ^^ expected `()`, found `i32`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: unknown start of token: \u{ff1b}\n  --> exercises/vecs/vecs2.rs:15:14\n   |\n15 |         *i*=2\n   |              ^^\n   |\nhelp: Unicode character '' (Fullwidth Semicolon) looks like ';' (Semicolon), but it is not\n   |\n15 |         *i*=2;\n   |              ~\n\nerror: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}

{"wrong_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec1` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:13:5\n   |\n9  |     let vec1 = fill_vec(vec0);\n   |         ---- help: consider changing this to be mutable: `mut vec1`\n...\n13 |     vec1.push(88);\n   |     ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: mut Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error: expected type, found keyword `mut`\n  --> exercises/move_semantics/move_semantics1.rs:18:18\n   |\n18 | fn fill_vec(vec: mut Vec<i32>) -> Vec<i32> {\n   |                  ^^^ expected type\n\nerror[E0423]: expected value, found macro `vec`\n  --> exercises/move_semantics/move_semantics1.rs:19:19\n   |\n19 |     let mut vec = vec;\n   |                   ^^^ not a value\n\nerror[E0282]: type annotations needed for `Vec<T>`\n --> exercises/move_semantics/move_semantics1.rs:7:9\n  |\n7 |     let vec0 = Vec::new();\n  |         ^^^^\n  |\nhelp: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified\n  |\n7 |     let vec0: Vec<T> = Vec::new();\n  |             ++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0282, E0423.\nFor more information about an error, try `rustc --explain E0282`.\n", "right_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let  vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:21:5\n   |\n19 |     let  vec = vec;\n   |          --- help: consider changing this to be mutable: `mut vec`\n20 |\n21 |     vec.push(22);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:22:5\n   |\n19 |     let  vec = vec;\n   |          --- help: consider changing this to be mutable: `mut vec`\n...\n22 |     vec.push(44);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:23:5\n   |\n19 |     let  vec = vec;\n   |          --- help: consider changing this to be mutable: `mut vec`\n...\n23 |     vec.push(66);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0382]: borrow of moved value: `vec0`\n  --> exercises/move_semantics/move_semantics2.rs:13:57\n   |\n8  |     let vec0 = Vec::new();\n   |         ---- move occurs because `vec0` has type `Vec<i32>`, which does not implement the `Copy` trait\n9  |\n10 |     let mut vec1 = fill_vec(vec0);\n   |                             ---- value moved here\n...\n13 |     println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n   |                                                         ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0.clone());\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0382]: borrow of moved value: `vec0`\n  --> exercises/move_semantics/move_semantics2.rs:11:57\n   |\n6  |     let vec0 = Vec::new();\n   |         ---- move occurs because `vec0` has type `Vec<i32>`, which does not implement the `Copy` trait\n7  |\n8  |     let mut vec1 = fill_vec(vec0);\n   |                             ---- value moved here\n...\n11 |     println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n   |                                                         ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0.clone());\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0).clone();\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0382]: borrow of moved value: `vec0`\n  --> exercises/move_semantics/move_semantics2.rs:11:57\n   |\n6  |     let vec0 = Vec::new();\n   |         ---- move occurs because `vec0` has type `Vec<i32>`, which does not implement the `Copy` trait\n7  |\n8  |     let mut vec1 = fill_vec(vec0).clone();\n   |                             ---- value moved here\n...\n11 |     println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n   |                                                         ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0.clone());\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:21:5\n   |\n20 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n21 |     vec.push(22);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:22:5\n   |\n20 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n21 |     vec.push(22);\n22 |     vec.push(44);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:23:5\n   |\n20 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n...\n23 |     vec.push(66);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:20:5\n   |\n19 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n20 |     vec.push(22);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:21:5\n   |\n19 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n20 |     vec.push(22);\n21 |     vec.push(44);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:22:5\n   |\n19 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n...\n22 |     vec.push(66);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec() -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0423]: expected value, found macro `vec`\n  --> exercises/move_semantics/move_semantics4.rs:23:19\n   |\n23 |     let mut vec = vec;\n   |                   ^^^ not a value\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n  --> exercises/move_semantics/move_semantics4.rs:12:20\n   |\n12 |     let mut vec1 = fill_vec(vec0);\n   |                    ^^^^^^^^ ---- argument of type `Vec<_>` unexpected\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics4.rs:22:4\n   |\n22 | fn fill_vec() -> Vec<i32> {\n   |    ^^^^^^^^\nhelp: remove the extra argument\n   |\n12 |     let mut vec1 = fill_vec();\n   |                            ~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0423.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error: expected one of `:`, `@`, or `|`, found `)`\n  --> exercises/move_semantics/move_semantics4.rs:22:16\n   |\n22 | fn fill_vec(vec) -> Vec<i32> {\n   |                ^ expected one of `:`, `@`, or `|`\n   |\n   = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)\nhelp: if this is a `self` type, give it a parameter name\n   |\n22 | fn fill_vec(self: vec) -> Vec<i32> {\n   |             +++++\nhelp: if this is a parameter name, give it a type\n   |\n22 | fn fill_vec(vec: TypeName) -> Vec<i32> {\n   |                ++++++++++\nhelp: if this is a type, explicitly ignore the parameter name\n   |\n22 | fn fill_vec(_: vec) -> Vec<i32> {\n   |             ++\n\nerror[E0282]: type annotations needed for `Vec<T>`\n  --> exercises/move_semantics/move_semantics4.rs:10:9\n   |\n10 |     let vec0 = Vec::new();\n   |         ^^^^\n   |\nhelp: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified\n   |\n10 |     let vec0: Vec<T> = Vec::new();\n   |             ++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:V) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0412]: cannot find type `V` in this scope\n  --> exercises/move_semantics/move_semantics4.rs:22:17\n   |\n22 | fn fill_vec(vec:V) -> Vec<i32> {\n   |            -    ^ not found in this scope\n   |            |\n   |            help: you might be missing a type parameter: `<V>`\n\nerror[E0282]: type annotations needed for `Vec<T>`\n  --> exercises/move_semantics/move_semantics4.rs:10:9\n   |\n10 |     let vec0 = Vec::new();\n   |         ^^^^\n   |\nhelp: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified\n   |\n10 |     let vec0: Vec<T> = Vec::new();\n   |             ++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0412.\nFor more information about an error, try `rustc --explain E0282`.\n", "right_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let mut x = 100;\n    let y = &mut x;\n    let z = &mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n11 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n12 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let mut x = 100;\n    let y = mut x;\n    let z = mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error: expected expression, found keyword `mut`\n  --> exercises/move_semantics/move_semantics5.rs:10:13\n   |\n10 |     let y = mut x;\n   |             ^^^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let mut x = 100;\n    let y = & x;\n    let z = & x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "warning: variable does not need to be mutable\n --> exercises/move_semantics/move_semantics5.rs:9:9\n  |\n9 |     let mut x = 100;\n  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0594]: cannot assign to `*y`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:12:5\n   |\n10 |     let y = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n11 |     let z = & x;\n12 |     *y += 100;\n   |     ^^^^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to `*z`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:13:5\n   |\n11 |     let z = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n12 |     *y += 100;\n13 |     *z += 1000;\n   |     ^^^^^^^^^^ `z` is a `&` reference, so the data it refers to cannot be written\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0594`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = & x;\n    let z = & x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0594]: cannot assign to `*y`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:12:5\n   |\n10 |     let y = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n11 |     let z = & x;\n12 |     *y += 100;\n   |     ^^^^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to `*z`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:13:5\n   |\n11 |     let z = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n12 |     *y += 100;\n13 |     *z += 1000;\n   |     ^^^^^^^^^^ `z` is a `&` reference, so the data it refers to cannot be written\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0594`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = & mutx;\n    let z = & x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0425]: cannot find value `mutx` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:10:15\n   |\n10 |     let y = & mutx;\n   |               ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = & mutx;\n    let z = & mutx;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0425]: cannot find value `mutx` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:10:15\n   |\n10 |     let y = & mutx;\n   |               ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `mutx` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:11:15\n   |\n11 |     let z = & mutx;\n   |               ^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = &mut x;\n    let z = &mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:10:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n10 |     let y = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n10 |     let y = &mut x;\n11 |     let z = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n11 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n12 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0499, E0596.\nFor more information about an error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:10:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n10 |     let y = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    \n    let z = &mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n14 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0277]: cannot add `()` to `{integer}`\n  --> exercises/move_semantics/move_semantics5.rs:15:8\n   |\n15 |     *y +\n   |        ^ no implementation for `{integer} + ()`\n   |\n   = help: the trait `Add<()>` is not implemented for `{integer}`\n   = help: the following other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +=100\n    assert_eq!(x, 1200);\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/move_semantics/move_semantics5.rs:15:13\n   |\n15 |     *y +=100\n   |             ^ help: add `;` here\n16 |     assert_eq!(x, 1200);\n   |     --------- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +=100\n    assert_eq!(x, 1300);\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/move_semantics/move_semantics5.rs:15:13\n   |\n15 |     *y +=100\n   |             ^ help: add `;` here\n16 |     assert_eq!(x, 1300);\n   |     --------- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +=100;\n    assert_eq!(x, 1300);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n14 |     *z += 1000;\n15 |     *y +=100;\n   |     -------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    \n    *y +=100;\n    *z += 1000;\n    assert_eq!(x, 1300);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n14 |     \n15 |     *y +=100;\n   |     -------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mutx = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0425]: cannot find value `x` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:10:18\n   |\n10 |     let y = &mut x;\n   |                  ^ not found in this scope\n\nerror[E0425]: cannot find value `x` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:13:18\n   |\n13 |     let z = &mut x;\n   |                  ^ help: a local variable with a similar name exists: `y`\n\nerror[E0425]: cannot find value `x` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:15:16\n   |\n15 |     assert_eq!(x, 1200);\n   |                ^ help: a local variable with a similar name exists: `y`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(data);\n\n    string_uppercase(&data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: &String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "warning: variable does not need to be mutable\n --> exercises/move_semantics/move_semantics6.rs:8:9\n  |\n8 |     let mut data = \"Rust is great!\".to_string();\n  |         ----^^^^\n  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved value: `data`\n  --> exercises/move_semantics/move_semantics6.rs:12:22\n   |\n8  |     let mut data = \"Rust is great!\".to_string();\n   |         -------- move occurs because `data` has type `String`, which does not implement the `Copy` trait\n9  |\n10 |     get_char(data);\n   |              ---- value moved here\n11 |\n12 |     string_uppercase(&data);\n   |                      ^^^^^ value borrowed here after move\n\nerror[E0716]: temporary value dropped while borrowed\n  --> exercises/move_semantics/move_semantics6.rs:22:13\n   |\n21 | fn string_uppercase(mut data: &String) {\n   |                               - let's call the lifetime of this reference `'1`\n22 |     data = &data.to_uppercase();\n   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement\n   |     |       |\n   |     |       creates a temporary which is freed while still in use\n   |     assignment requires that borrow lasts for `'1`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0382, E0716.\nFor more information about an error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}
{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(&data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: &String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:10:14\n   |\n10 |     get_char(&data);\n   |     -------- ^^^^^ expected struct `String`, found `&String`\n   |     |\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:16:4\n   |\n16 | fn get_char(data: String) -> char {\n   |    ^^^^^^^^ ------------\nhelp: consider removing the borrow\n   |\n10 -     get_char(&data);\n10 +     get_char(data);\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}
{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: &String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:10:14\n   |\n10 |     get_char(&data);\n   |     -------- ^^^^^ expected struct `String`, found `&String`\n   |     |\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:16:4\n   |\n16 | fn get_char(data: String) -> char {\n   |    ^^^^^^^^ ------------\nhelp: consider removing the borrow\n   |\n10 -     get_char(&data);\n10 +     get_char(data);\n   |\n\nerror[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:12:22\n   |\n12 |     string_uppercase(data);\n   |     ---------------- ^^^^\n   |     |                |\n   |     |                expected `&String`, found struct `String`\n   |     |                help: consider borrowing here: `&data`\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:21:4\n   |\n21 | fn string_uppercase(mut data: &String) {\n   |    ^^^^^^^^^^^^^^^^ -----------------\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}
{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:10:14\n   |\n10 |     get_char(&data);\n   |     -------- ^^^^^ expected struct `String`, found `&String`\n   |     |\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:16:4\n   |\n16 | fn get_char(data: String) -> char {\n   |    ^^^^^^^^ ------------\nhelp: consider removing the borrow\n   |\n10 -     get_char(&data);\n10 +     get_char(data);\n   |\n\nerror[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:22:12\n   |\n21 | fn string_uppercase(mut data: String) {\n   |                               ------ expected due to this parameter type\n22 |     data = &data.to_uppercase();\n   |            ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n22 -     data = &data.to_uppercase();\n22 +     data = data.to_uppercase();\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}

{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct ColorClassicStruct {\n    // TODO: Something goes here\n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:25:20\n   |\n25 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:26:20\n   |\n26 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:35:20\n   |\n35 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:36:20\n   |\n36 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:44:49\n   |\n14 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n44 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:18:9\n   |\n18 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:\n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected type, found `}`\n  --> exercises/structs/structs1.rs:10:1\n   |\n10 | }\n   | ^ expected type\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:26:20\n   |\n26 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:36:20\n   |\n36 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:45:49\n   |\n15 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n45 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:19:9\n   |\n19 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32\n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:26:20\n   |\n26 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:36:20\n   |\n36 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:45:49\n   |\n15 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n45 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:19:9\n   |\n19 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32,\n   \n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:29:20\n   |\n29 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:46:49\n   |\n16 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n46 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:20:9\n   |\n20 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct();\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:46:49\n   |\n16 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n46 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:20:9\n   |\n20 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0412]: cannot find type `u` in this scope\n  --> exercises/structs/structs1.rs:13:29\n   |\n13 | struct ColorTupleStruct(u32,u);\n   |                             ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:46:49\n   |\n16 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n46 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:20:9\n   |\n20 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected type, found `}`\n  --> exercises/structs/structs1.rs:12:1\n   |\n12 | }\n   | ^ expected type\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:40:20\n   |\n40 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:47:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n47 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32\n\n};\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected item, found `;`\n  --> exercises/structs/structs1.rs:12:2\n   |\n12 | };\n   |  ^ help: remove this semicolon\n   |\n   = help: braced struct declarations are not followed by a semicolon\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:40:20\n   |\n40 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:47:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n47 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:40:20\n   |\n40 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:47:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n47 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =struct ColorClassicStruct {\n            red :i32,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected expression, found keyword `struct`\n  --> exercises/structs/structs1.rs:26:21\n   |\n26 |          let green =struct ColorClassicStruct {\n   |                     ^^^^^^ expected expression\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :i32,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:27:18\n   |\n27 |             red :i32,\n   |                  ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:28:19\n   |\n28 |             green:i32,\n   |                   ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected expression, found `,`\n  --> exercises/structs/structs1.rs:27:18\n   |\n26 |          let green =ColorClassicStruct {\n   |                     ------------------ while parsing this struct\n27 |             red :,\n   |                  ^ expected expression\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:28:19\n   |\n28 |             green:i32,\n   |                   ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:28:19\n   |\n28 |             green:i32,\n   |                   ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(u32,u32,u32);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:38\n   |\n41 |          let green =ColorTupleStruct(u32,u32,u32);\n   |                                      ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:42\n   |\n41 |          let green =ColorTupleStruct(u32,u32,u32);\n   |                                          ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:46\n   |\n41 |          let green =ColorTupleStruct(u32,u32,u32);\n   |                                              ^^^ not a value\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,u32,u32);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:40\n   |\n41 |          let green =ColorTupleStruct(0,u32,u32);\n   |                                        ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:44\n   |\n41 |          let green =ColorTupleStruct(0,u32,u32);\n   |                                            ^^^ not a value\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found keyword `let`\n  --> exercises/structs/structs1.rs:51:46\n   |\n51 |          let unit_like_struct =UnitLikeStruct\n   |                                              ^ help: add `;` here\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |         --- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}

{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n        // let your_order =\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error[E0609]: no field `name` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:39:31\n   |\n39 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |                               ^^^^\n\nerror[E0609]: no field `year` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:40:31\n   |\n40 |         assert_eq!(your_order.year, order_template.year);\n   |                               ^^^^\n\nerror[E0609]: no field `made_by_phone` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:41:31\n   |\n41 |         assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_mobile` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:42:31\n   |\n42 |         assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n   |                               ^^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_email` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:43:31\n   |\n43 |         assert_eq!(your_order.made_by_email, order_template.made_by_email);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `item_number` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:44:31\n   |\n44 |         assert_eq!(your_order.item_number, order_template.item_number);\n   |                               ^^^^^^^^^^^\n\nerror[E0609]: no field `count` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:45:31\n   |\n45 |         assert_eq!(your_order.count, 1);\n   |                               ^^^^^\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error[E0609]: no field `name` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:39:31\n   |\n39 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |                               ^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =\n         {\n            \n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0609]: no field `name` on type `()`\n  --> exercises/structs/structs2.rs:42:31\n   |\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |                               ^^^^\n\nerror[E0609]: no field `year` on type `()`\n  --> exercises/structs/structs2.rs:43:31\n   |\n43 |         assert_eq!(your_order.year, order_template.year);\n   |                               ^^^^\n\nerror[E0609]: no field `made_by_phone` on type `()`\n  --> exercises/structs/structs2.rs:44:31\n   |\n44 |         assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_mobile` on type `()`\n  --> exercises/structs/structs2.rs:45:31\n   |\n45 |         assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n   |                               ^^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_email` on type `()`\n  --> exercises/structs/structs2.rs:46:31\n   |\n46 |         assert_eq!(your_order.made_by_email, order_template.made_by_email);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `item_number` on type `()`\n  --> exercises/structs/structs2.rs:47:31\n   |\n47 |         assert_eq!(your_order.item_number, order_template.item_number);\n   |                               ^^^^^^^^^^^\n\nerror[E0609]: no field `count` on type `()`\n  --> exercises/structs/structs2.rs:48:31\n   |\n48 |         assert_eq!(your_order.count, 1);\n   |                               ^^^^^\n\nerror: aborting due to 8 previous errors\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected expression, found `}`\n  --> exercises/structs/structs2.rs:41:10\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n...\n41 |          }\n   |          ^ expected expression\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror[E0425]: cannot find value `name` in this scope\n  --> exercises/structs/structs2.rs:40:13\n   |\n40 |             name\n   |             ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0425.\nFor more information about an error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name=\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `:`, found `=`\n  --> exercises/structs/structs2.rs:40:17\n   |\n40 |             name=\n   |                 ^ help: replace equals symbol with a colon: `:`\n\nerror: expected expression, found `}`\n  --> exercises/structs/structs2.rs:41:10\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n...\n41 |          }\n   |          ^ expected expression\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name=\"Hacker in Rust\".to_string()\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `:`, found `=`\n  --> exercises/structs/structs2.rs:40:17\n   |\n40 |             name=\"Hacker in Rust\".to_string()\n   |                 ^ help: replace equals symbol with a colon: `:`\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name=\"Hacker in Rust\".to_string();\n            count:\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `:`, found `=`\n  --> exercises/structs/structs2.rs:40:17\n   |\n40 |             name=\"Hacker in Rust\".to_string();\n   |                 ^ help: replace equals symbol with a colon: `:`\n\nerror: expected one of `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> exercises/structs/structs2.rs:40:46\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n39 |          {\n40 |             name=\"Hacker in Rust\".to_string();\n   |                                              ^ expected one of `,`, `.`, `?`, `}`, or an operator\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string();\n            count:1\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> exercises/structs/structs2.rs:40:46\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n39 |          {\n40 |             name:\"Hacker in Rust\".to_string();\n   |                                              ^\n   |                                              |\n   |                                              expected one of `,`, `.`, `?`, `}`, or an operator\n   |                                              help: try adding a comma: `,`\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string()\n            count:1\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `count`\n  --> exercises/structs/structs2.rs:41:13\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n39 |          {\n40 |             name:\"Hacker in Rust\".to_string()\n   |                                              -\n   |                                              |\n   |                                              expected one of `,`, `.`, `?`, `}`, or an operator\n   |                                              help: try adding a comma: `,`\n41 |             count:1\n   |             ^^^^^ unexpected token\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            \n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:43:11\n   |\n43 |          }\n   |           ^ help: add `;` here\n44 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:43:11\n   |\n43 |          }\n   |           ^ help: add `;` here\n44 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}

{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> ??? {\n        // Something goes here...\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> ??? {\n        // Something goes here...\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/structs/structs3.rs:29:36\n   |\n16 | impl Package {\n   |              - while parsing this item list starting here\n...\n29 |     fn is_international(&self) -> ??? {\n   |                                    ^ expected identifier\n...\n36 | }\n   | - the item list ends here\n\nerror[E0599]: no method named `is_international` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:58:25\n   |\n10 | struct Package {\n   | -------------- method `is_international` not found for this struct\n...\n58 |         assert!(package.is_international());\n   |                         ^^^^^^^^^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `is_international` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:68:26\n   |\n10 | struct Package {\n   | -------------- method `is_international` not found for this struct\n...\n68 |         assert!(!package.is_international());\n   |                          ^^^^^^^^^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:80:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n80 |         assert_eq!(package.get_fees(cents_per_gram), 4500);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:81:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n81 |         assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        // Something goes here...\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> ??? {\n        // Something goes here...\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/structs/structs3.rs:33:49\n   |\n16 | impl Package {\n   |              - while parsing this item list starting here\n...\n33 |     fn get_fees(&self, cents_per_gram: i32) -> ??? {\n   |                                                 ^ expected identifier\n...\n36 | }\n   | - the item list ends here\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:80:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n80 |         assert_eq!(package.get_fees(cents_per_gram), 4500);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:81:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n81 |         assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        \n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        // Something goes here...\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:33:48\n   |\n33 |     fn get_fees(&self, cents_per_gram: i32) -> i32{\n   |        --------                                ^^^ expected `i32`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n   |\nhelp: consider returning the local binding `cents_per_gram`\n   |\n33 ~     fn get_fees(&self, cents_per_gram: i32) -> i32{\n34 +         cents_per_gram\n35 ~     // Something goes here...\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        \n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        \n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/structs/structs3.rs:31:5\n   |\n31 |     }\n   |     ^\n\nerror[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:30:9\n   |\n29 |     fn is_international(&self) -> bool {\n   |                                   ---- expected `bool` because of return type\n30 |         self.\n   |         ^^^^ expected `bool`, found `&Package`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:30:9\n   |\n29 |     fn is_international(&self) -> bool {\n   |                                   ---- expected `bool` because of return type\n30 |         self.sender_country\n   |         ^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: expected expression, found `}`\n  --> exercises/structs/structs3.rs:31:5\n   |\n31 |     }\n   |     ^ expected expression\n\nerror[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `recipient_country` in this scope\n  --> exercises/structs/structs3.rs:30:30\n   |\n30 |         self.sender_country!=recipient_country\n   |                              ^^^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.recipient_country`\n\nerror[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `recipient_country` in this scope\n  --> exercises/structs/structs3.rs:30:30\n   |\n30 |         self.sender_country!=recipient_country\n   |                              ^^^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.recipient_country`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=srecipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `srecipient_country` in this scope\n  --> exercises/structs/structs3.rs:30:30\n   |\n30 |         self.sender_country!=srecipient_country\n   |                              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.wcents_per_gram*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0609]: no field `wcents_per_gram` on type `&Package`\n  --> exercises/structs/structs3.rs:34:14\n   |\n34 |         self.wcents_per_gram*3\n   |              ^^^^^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `sender_country`, `recipient_country`, `weight_in_grams`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.cents_per_gram*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0609]: no field `cents_per_gram` on type `&Package`\n  --> exercises/structs/structs3.rs:34:14\n   |\n34 |         self.cents_per_gram*3\n   |              ^^^^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `sender_country`, `recipient_country`, `weight_in_grams`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}

{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define a few types of messages as used below\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:12:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n12 |     println!(\"{:?}\", Message::Quit);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:13:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n13 |     println!(\"{:?}\", Message::Echo);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:14:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Move` not found for this enum\n...\n14 |     println!(\"{:?}\", Message::Move);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:15:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n15 |     println!(\"{:?}\", Message::ChangeColor);\n   |                               ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}
{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error: expected item, found `;`\n --> exercises/enums/enums1.rs:8:10\n  |\n8 |     Quit);\n  |          ^ help: remove this semicolon\n  |\n  = help: enum declarations are not followed by a semicolon\n\nerror: macros that expand to items must be delimited with braces or followed by a semicolon\n  --> exercises/enums/enums1.rs:11:13\n   |\n11 |       println!(\"{:?}\", Message::ChangeColor\n   |  _____________^\n12 | | }\n   | |_^\n   |\nhelp: change the delimiters to curly braces\n   |\n11 |     println! { /* items */ }\n   |              ~~~~~~~~~~~~~~~\nhelp: add a semicolon\n   |\n12 | };\n   |  +\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums1.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     Quit);\n  |         ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums1.rs:11:13\n   |\n11 |     println!(\"{:?}\", Message::ChangeColor\n   |             ^ unclosed delimiter\n12 | }\n   | ^ mismatched closing delimiter\n\nerror: macro expansion ignores token `{` and any following\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:135:23\n    |\n135 |       ($($arg:tt)*) => {{\n    |  _______________________^\n136 | |         $crate::io::_print($crate::format_args_nl!($($arg)*));\n137 | |     }};\n    | |_____^\n    |\n   ::: exercises/enums/enums1.rs:9:5\n    |\n9   |       println!(\"{:?}\", Message::Echo);\n    |       ------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `println!` is likely invalid in item context\n\nerror: macro expansion ignores token `{` and any following\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:135:23\n    |\n135 |       ($($arg:tt)*) => {{\n    |  _______________________^\n136 | |         $crate::io::_print($crate::format_args_nl!($($arg)*));\n137 | |     }};\n    | |_____^\n    |\n   ::: exercises/enums/enums1.rs:10:5\n    |\n10  |       println!(\"{:?}\", Message::Move);\n    |       ------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `println!` is likely invalid in item context\n\nerror: macro expansion ignores token `{` and any following\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:135:23\n    |\n135 |       ($($arg:tt)*) => {{\n    |  _______________________^\n136 | |         $crate::io::_print($crate::format_args_nl!($($arg)*));\n137 | |     }};\n    | |_____^\n    |\n   ::: exercises/enums/enums1.rs:11:5\n    |\n11  | /     println!(\"{:?}\", Message::ChangeColor\n12  | | }\n    | |_- caused by the macro expansion here\n    |\n    = note: the usage of `println!` is likely invalid in item context\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:16:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n16 |     println!(\"{:?}\", Message::Echo);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:17:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Move` not found for this enum\n...\n17 |     println!(\"{:?}\", Message::Move);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:18:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n18 |     println!(\"{:?}\", Message::ChangeColor);\n   |                               ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 10 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}
{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    Quit);\n    Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error: unexpected closing delimiter: `)`\n --> exercises/enums/enums1.rs:9:9\n  |\n9 |     Echo);\n  |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums1.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     Quit);\n  |         ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}
{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    Quit\n    Echo\n    Move\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error: expected one of `(`, `,`, `=`, `{`, or `}`, found `Echo`\n --> exercises/enums/enums1.rs:9:5\n  |\n8 |     Quit\n  |         -\n  |         |\n  |         expected one of `(`, `,`, `=`, `{`, or `}`\n  |         help: missing `,`\n9 |     Echo\n  |     ^^^^ unexpected token\n\nerror: expected one of `(`, `,`, `=`, `{`, or `}`, found `Move`\n  --> exercises/enums/enums1.rs:10:5\n   |\n9  |     Echo\n   |         -\n   |         |\n   |         expected one of `(`, `,`, `=`, `{`, or `}`\n   |         help: missing `,`\n10 |     Move\n   |     ^^^^ unexpected token\n\nerror: expected one of `(`, `,`, `=`, `{`, or `}`, found `ChangeColor`\n  --> exercises/enums/enums1.rs:11:5\n   |\n10 |     Move\n   |         -\n   |         |\n   |         expected one of `(`, `,`, `=`, `{`, or `}`\n   |         help: missing `,`\n11 |     ChangeColor\n   |     ^^^^^^^^^^^ unexpected token\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}

{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define the different variants used below\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error[E0599]: no variant named `Move` found for enum `Message`\n  --> exercises/enums/enums2.rs:19:18\n   |\n7  | enum Message {\n   | ------------ variant `Move` not found here\n...\n19 |         Message::Move { x: 10, y: 30 },\n   |                  ^^^^ variant not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:20:18\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n20 |         Message::Echo(String::from(\"hello world\")),\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:21:18\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n21 |         Message::ChangeColor(200, 255, 255),\n   |                  ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:22:18\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n22 |         Message::Quit,\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define the different variants used below\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error[E0599]: no variant named `Move` found for enum `Message`\n  --> exercises/enums/enums2.rs:18:18\n   |\n6  | enum Message {\n   | ------------ variant `Move` not found here\n...\n18 |         Message::Move { x: 10, y: 30 },\n   |                  ^^^^ variant not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:19:18\n   |\n6  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n19 |         Message::Echo(String::from(\"hello world\")),\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:20:18\n   |\n6  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n20 |         Message::ChangeColor(200, 255, 255),\n   |                  ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:21:18\n   |\n6  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n21 |         Message::Quit,\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: 10, y: 30 },\nEcho(String::from(\"hello world\")),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `10`\n --> exercises/enums/enums2.rs:7:15\n  |\n7 |     Move { x: 10, y: 30 },\n  |               ^^ expected type\n\nerror: expected type, found `\"hello world\"`\n --> exercises/enums/enums2.rs:8:19\n  |\n8 | Echo(String::from(\"hello world\")),\n  |                   ^^^^^^^^^^^^^ expected type\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: 30 },\nEcho(String::from(\"hello world\")),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `30`\n --> exercises/enums/enums2.rs:7:23\n  |\n7 |     Move { x: i32, y: 30 },\n  |                       ^^ expected type\n\nerror: expected type, found `\"hello world\"`\n --> exercises/enums/enums2.rs:8:19\n  |\n8 | Echo(String::from(\"hello world\")),\n  |                   ^^^^^^^^^^^^^ expected type\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String::from(\"hello world\")),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `\"hello world\"`\n --> exercises/enums/enums2.rs:8:19\n  |\n8 | Echo(String::from(\"hello world\")),\n  |                   ^^^^^^^^^^^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `200`\n --> exercises/enums/enums2.rs:9:13\n  |\n9 | ChangeColor(200, 255, 255),\n  |             ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums2.rs:9:18\n  |\n9 | ChangeColor(u32, 255, 255),\n  |                  ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums2.rs:9:23\n  |\n9 | ChangeColor(u32, u32, 255),\n  |                       ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}

{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nenum Message {\n    // TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:55:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n55 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:56:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n56 |         state.process(Message::Echo(String::from(\"hello world\")));\n   |                                ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:57:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Move` not found for this enum\n...\n57 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                                ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:58:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n58 |         state.process(Message::Quit);\n   |                                ^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String::from(\"hello world\"\nMove(Point { x: 10, y: 15 }));\nQuit);// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:13:1\n   |\n11 | Move(Point { x: 10, y: 15 }));\n   |            -              - ...matches this closing brace\n   |            |\n   |            this opening brace...\n12 | Quit);// TODO: implement the message variant types based on their usage below\n13 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor((255, 0, 255)));\n  |                               ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String::from(\"hello world\"\nMove(Point { x: 10, y: 15 }));\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums3.rs:9:18\n  |\n9 |     ChangeColor((255, 0, 255)));\n  |                  ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String::from(\"hello world\"\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: this file contains an unclosed delimiter\n  --> exercises/enums/enums3.rs:70:3\n   |\n10 | Echo(String::from(\"hello world\"\n   |     - unclosed delimiter\n...\n70 | }\n   |   ^\n\nerror: expected type, found `255`\n --> exercises/enums/enums3.rs:9:18\n  |\n9 |     ChangeColor((255, 0, 255)));\n  |                  ^^^ expected type\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:14:1\n   |\n14 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor((255, 0, 255)));\n  |                               ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32, , 255)));\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `)`\n --> exercises/enums/enums3.rs:9:29\n  |\n9 |     ChangeColor(u32, , 255)));\n  |                             ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor(u32, , 255)));\n  |                            ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, 255)));\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `)`\n --> exercises/enums/enums3.rs:9:31\n  |\n9 |     ChangeColor(u32,u32, 255)));\n  |                               ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor(u32,u32, 255)));\n  |                              ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, 255);\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums3.rs:9:26\n  |\n9 |     ChangeColor(u32,u32, 255);\n  |                          ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32,;\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `;`\n --> exercises/enums/enums3.rs:9:30\n  |\n9 |     ChangeColor(u32,u32, u32,;\n  |                              ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:60:23\n   |\n60 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:60:44\n   |\n60 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n60 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:62:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n62 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        \n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:61:23\n   |\n61 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:61:44\n   |\n61 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n61 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:63:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n63 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)));\nMessage::Echo(String::from(\"hello world\")));\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:50:9\n   |\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                     -              - ...matches this closing brace\n   |                     |\n   |                     this opening brace...\n50 |         } {\n   |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)));\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:44:45\n   |\n44 |     fn process(&mut self, message: Message) {\n   |                                             ^ unclosed delimiter\n...\n48 | Message::Echo(String::from(\"hello world\")));\n   |                                           ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:27:12\n   |\n27 | impl State {\n   |            ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)))=?;\nMessage::Echo(String::from(\"hello world\")));\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:50:9\n   |\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                     -              - ...matches this closing brace\n   |                     |\n   |                     this opening brace...\n50 |         } {\n   |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)))=?;\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:44:45\n   |\n44 |     fn process(&mut self, message: Message) {\n   |                                             ^ unclosed delimiter\n...\n48 | Message::Echo(String::from(\"hello world\")));\n   |                                           ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:27:12\n   |\n27 | impl State {\n   |            ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)))=>;\nMessage::Echo(String::from(\"hello world\")));\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:50:9\n   |\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                     -              - ...matches this closing brace\n   |                     |\n   |                     this opening brace...\n50 |         } {\n   |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)))=>;\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:44:45\n   |\n44 |     fn process(&mut self, message: Message) {\n   |                                             ^ unclosed delimiter\n...\n48 | Message::Echo(String::from(\"hello world\")));\n   |                                           ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:27:12\n   |\n27 | impl State {\n   |            ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)))=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:54:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n53 |     }\n   |     - ...matches this closing brace\n54 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)))=>;\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor())=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:54:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n53 |     }\n   |     - ...matches this closing brace\n54 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor())=>;\n   |                                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor()=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:35\n   |\n47 |             Message::ChangeColor()=>;\n   |                                   ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor()=>;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>;\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.;\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(color);\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(color);\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.change_color(color);\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color;\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.change_color;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c);\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c);\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.change_color(c);\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c);\nMessage::Echo(s);\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:54:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n53 |     }\n   |     - ...matches this closing brace\n54 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c);\nMessage::Echo(s)=>self.echo(s);\nMessage::Move();\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c);\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\nMessage::Echo(s)=>self.echo(s),\nMessage::Move(p)=>self.move_position(p);\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            \n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:55:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n54 |     }\n   |     - ...matches this closing brace\n55 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `?`, `{`, or an operator, found `}`\n  --> exercises/enums/enums3.rs:53:9\n   |\n46 |         match {\n   |         ----- while parsing this `match` expression\n...\n51 |         } \n   |          - expected one of `.`, `?`, `{`, or an operator\n52 |             \n53 |         }\n   |         ^ unexpected token\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n}=\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:55:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n54 |     }\n   |     - ...matches this closing brace\n55 | }=\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n}}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:55:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n54 |     }\n   |     - ...matches this closing brace\n55 | }}\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0425]: cannot find value `c` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `C`\n\nerror[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |                 --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(c),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(c),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0425, E0532, E0618.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |                 --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0532, E0618.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    \n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: this file contains an unclosed delimiter\n  --> exercises/enums/enums3.rs:78:3\n   |\n27 | impl State {\n   |            - unclosed delimiter\n...\n44 |     fn process(&mut self, message: Message) {\n   |                                             - this delimiter might not be properly closed...\n...\n53 |         }\n   |         - ...as it matches this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror: module is not supported in `trait`s or `impl`s\n  --> exercises/enums/enums3.rs:58:1\n   |\n58 | mod tests {\n   | ^^^^^^^^^\n   |\n   = help: consider moving the module out to a nearby module scope\n\nerror[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |                 --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0532.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0532, E0618.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 0 fields\n  --> exercises/enums/enums3.rs:49:27\n   |\n11 | Move(),\n   | ---- tuple variant has 0 fields\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |                           ^ expected 0 fields, found 1\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this enum variant takes 0 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:70:23\n   |\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^ ---------------------- argument of type `Point` unexpected\n   |\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:11:1\n   |\n11 | Move(),\n   | ^^^^\nhelp: remove the extra argument\n   |\n70 |         state.process(Message::Move());\n   |                                    ~~\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `point` in this scope\n  --> exercises/enums/enums3.rs:11:6\n   |\n11 | Move(point),\n   |      ^^^^^ help: a struct with a similar name exists: `Point`\n...\n16 | struct Point {\n   | ------------ similarly named struct `Point` defined here\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0412.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point{x}),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n  --> exercises/enums/enums3.rs:11:11\n   |\n11 | Move(point{x}),\n   |           ^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point{x:i32}),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n  --> exercises/enums/enums3.rs:11:11\n   |\n11 | Move(point{x:i32}),\n   |           ^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point{x:i32,y:i32}),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n  --> exercises/enums/enums3.rs:11:11\n   |\n11 | Move(point{x:i32,y:i32}),\n   |           ^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0425]: cannot find value `C` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(c)=>self.change_color(C),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `c`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(c)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(c, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(c, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0425.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c:c)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> exercises/enums/enums3.rs:47:35\n   |\n47 |             Message::ChangeColor(c:c)=>self.change_color(C),\n   |                                   ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c:co)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> exercises/enums/enums3.rs:47:35\n   |\n47 |             Message::ChangeColor(c:co)=>self.change_color(C),\n   |                                   ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(c),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `c` in this scope\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor(c),\n  |             ^ not found in this scope\n\nerror[E0425]: cannot find value `C` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(c)=>self.change_color(C),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `c`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(c),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `c` in this scope\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor(c),\n  |             ^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0412`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(c),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `c` in this scope\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor(c),\n  |             ^ not found in this scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `C`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}

{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `{`\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor({(u8, u8, u8)),\n  |             ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)}),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `{`\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor({(u8, u8, u8)}),\n  |             ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)]),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `{`\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor({(u8, u8, u8)]),\n  |             ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor([(u8, u8, u8)]),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0277]: the size for values of type `[(u8, u8, u8)]` cannot be known at compilation time\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor([(u8, u8, u8)]),\n  |             ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `[(u8, u8, u8)]`\n  = note: no field of an enum variant may have a dynamically sized type\n  = help: change the field's type to have a statically known size\nhelp: borrowed types always have a statically known size\n  |\n9 | ChangeColor(&[(u8, u8, u8)]),\n  |             +\nhelp: the `Box` type always has a statically known size and allocates its contents in the heap\n  |\n9 | ChangeColor(Box<[(u8, u8, u8)]>),\n  |             ++++              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)]),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:14:1\n   |\n14 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `]`\n --> exercises/enums/enums3.rs:9:12\n  |\n9 | ChangeColor((u8, u8, u8)]),\n  |            ^            ^ mismatched closing delimiter\n  |            |\n  |            unclosed delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 | ChangeColor((u8, u8, u8)]),\n  |                          ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}

{"wrong_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\"\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/strings/strings1.rs:13:5\n   |\n12 | fn current_favorite_color() -> String {\n   |                                ------ expected `String` because of return type\n13 |     \"blue\"\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_string()\n}\n"}
{"wrong_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to\n}\n", "error": "error[E0609]: no field `to` on type `&'static str`\n  --> exercises/strings/strings1.rs:13:12\n   |\n13 |     \"blue\".to\n   |            ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_string()\n}\n"}
{"wrong_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_\n}\n", "error": "error[E0609]: no field `to_` on type `&'static str`\n  --> exercises/strings/strings1.rs:13:12\n   |\n13 |     \"blue\".to_\n   |            ^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_string()\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    let z = &mut x;\n    *y += 100;\n    \n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n11 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n12 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    *y += 100;\n    let z = &mut x;\n   \n    \n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn trim_me(input: &str) -> String {\n    // TODO: Remove whitespace from both ends of a string!\n    ???\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n --> exercises/strings/strings3.rs:8:5\n  |\n8 |     ???\n  |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:13:5\n   |\n13 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:18:5\n   |\n18 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    in\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found keyword `in`\n --> exercises/strings/strings3.rs:7:5\n  |\n7 |     in\n  |     ^^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `trim` on type `&str`\n --> exercises/strings/strings3.rs:7:11\n  |\n7 |     input.trim\n  |           ^^^^ method, not a field\n  |\nhelp: use parentheses to call the method\n  |\n7 |     input.trim()\n  |               ++\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0609]: no field `to` on type `&str`\n --> exercises/strings/strings3.rs:7:18\n  |\n7 |     input.trim().to\n  |                  ^^\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string(())\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n    --> exercises/strings/strings3.rs:7:18\n     |\n7    |     input.trim().to_string(())\n     |                  ^^^^^^^^^ -- argument of type `()` unexpected\n     |\nnote: associated function defined here\n    --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2489:8\n     |\n2489 |     fn to_string(&self) -> String;\n     |        ^^^^^^^^^\nhelp: remove the extra argument\n     |\n7    |     input.trim().to_string()\n     |                           ~~\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    in\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found keyword `in`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     in\n   |     ^^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    input.to_string+\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `}`\n  --> exercises/strings/strings3.rs:13:1\n   |\n13 | }\n   | ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    input.to_string+\" world!\"\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:11\n   |\n12 |     input.to_string+\" world!\"\n   |           ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     input.to_string()+\" world!\"\n   |                    ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\"\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/strings/strings3.rs:12:5\n   |\n10 | fn compose_me(input: &str) -> String {\n   |                                      - closing delimiter possibly meant for this\n11 |     // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n12 |     (input.to_string+\" world!\"\n   |     ^ unclosed delimiter\n13 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around block return value\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |       (input.to_string+\" world!\"\n   |  _____^_________________________^\n13 | | }\n   | |_^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     (input.to_string+\" world!\"\n12 +     input.to_string+\" world!\"\n   |\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\"\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\"\n   |                     ++\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\").to_string\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\").to_string\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\").to_string\n   |                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\").to_string()\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\").to_string()\n   |                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ?\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ?\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\").to_string()\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\").to_string()\n   |                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ?\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ?\n   |     ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    re\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find value `re` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     re\n   |     ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    replace\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find value `replace` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     replace\n   |     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n6  | use std::mem::replace;\n   |\n6  | use std::ptr::replace;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    replace()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find function `replace` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     replace()\n   |     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n6  | use std::mem::replace;\n   |\n6  | use std::ptr::replace;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    inreplace()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find function `inreplace` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     inreplace()\n   |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0061]: this function takes 2 arguments but 0 arguments were supplied\n   --> exercises/strings/strings3.rs:17:11\n    |\n17  |     input.replace()\n    |           ^^^^^^^-- two arguments are missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:271:12\n    |\n271 |     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n    |            ^^^^^^^\nhelp: provide the arguments\n    |\n17  |     input.replace(/* value */, /* &str */)\n    |                  ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> exercises/strings/strings3.rs:17:11\n    |\n17  |     input.replace(\"cars\")\n    |           ^^^^^^^-------- an argument of type `&str` is missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:271:12\n    |\n271 |     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n    |            ^^^^^^^\nhelp: provide the argument\n    |\n17  |     input.replace(\"cars\", /* &str */)\n    |                  ~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"ballons\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/strings/strings3.rs:15:31\n   |\n15 | fn replace_me(input: &str) -> String {\n   |    ----------                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n16 |     // TODO: Replace \"cars\" in the string with \"balloons\"!\n17 |     input.replace(\"cars\",\"ballons\");\n   |                                    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"ballons\").\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/strings/strings3.rs:18:1\n   |\n18 | }\n   | ^\n\nerror: aborting due to previous error\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(ballons\").\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/strings/strings3.rs:40:85\n   |\n40 |           assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n   |  _____________________________________________________________________________________^\n41 | |     }\n42 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"ballons\").\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/strings/strings3.rs:18:1\n   |\n18 | }\n   | ^\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> exercises/strings/strings3.rs:17:11\n    |\n17  |     input.replace(\"ballons\").\n    |           ^^^^^^^----------- an argument of type `&str` is missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:271:12\n    |\n271 |     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n    |            ^^^^^^^\nhelp: provide the argument\n    |\n17  |     input.replace(\"ballons\", /* &str */).\n    |                  ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"ballons\").t\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0609]: no field `t` on type `String`\n  --> exercises/strings/strings3.rs:17:37\n   |\n17 |     input.replace(\"cars\",\"ballons\").t\n   |                                     ^ unknown field\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}

{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    ???(\"blue\");\n    ???(\"red\".to_string());\n    ???(String::from(\"hi\"));\n    ???(\"rust is fun!\".to_owned());\n    ???(\"nice weather\".into());\n    ???(format!(\"Interpolation {}\", \"Station\"));\n    ???(&String::from(\"abc\")[0..1]);\n    ???(\"  hello there \".trim());\n    ???(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    ???(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     ???(\"blue\");\n   |     ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    (\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0282]: type annotations needed\n  --> exercises/strings/strings4.rs:23:21\n   |\n23 |     (\"nice weather\".into());\n   |                     ^^^^\n   |\nhelp: try using a fully qualified path to specify the expected types\n   |\n23 |     (<&str as Into<T>>::into(\"nice weather\"));\n   |      ++++++++++++++++++++++++              ~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    S(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function, tuple struct or tuple variant `S` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     S(\"blue\");\n   |     ^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    St(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function, tuple struct or tuple variant `St` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     St(\"blue\");\n   |     ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    string_slice(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function `st` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     st(\"blue\");\n   |     ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    string_slice(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function `string_slice` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     string_slice(\"blue\");\n   |     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    (st\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `\"nice weather\"`\n  --> exercises/strings/strings4.rs:23:8\n   |\n23 |     (st\"nice weather\".into());\n   |        -^^^^^^^^^^^^^\n   |        |\n   |        expected one of 8 possible tokens\n   |        help: missing `,`\n\nerror[E0283]: type annotations needed\n  --> exercises/strings/strings4.rs:23:23\n   |\n23 |     (st\"nice weather\".into());\n   |                       ^^^^\n   |\n   = note: cannot satisfy `_: From<&str>`\n   = note: required for `&str` to implement `Into<_>`\nhelp: try using a fully qualified path to specify the expected types\n   |\n23 |     (st<&str as Into<T>>::into(\"nice weather\"));\n   |        ++++++++++++++++++++++++              ~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0283`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}

{"wrong_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n", "error": "error[E0603]: function `make_sausage` is private\n  --> exercises/modules/modules1.rs:19:22\n   |\n19 |     sausage_factory::make_sausage();\n   |                      ^^^^^^^^^^^^ private function\n   |\nnote: the function `make_sausage` is defined here\n  --> exercises/modules/modules1.rs:12:5\n   |\n12 |     fn make_sausage() {\n   |     ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    pub fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n"}
{"wrong_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n", "error": "error[E0603]: function `make_sausage` is private\n  --> exercises/modules/modules1.rs:17:22\n   |\n17 |     sausage_factory::make_sausage();\n   |                      ^^^^^^^^^^^^ private function\n   |\nnote: the function `make_sausage` is defined here\n  --> exercises/modules/modules1.rs:10:5\n   |\n10 |     fn make_sausage() {\n   |     ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    pub fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n"}

{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as ???\n    use self::veggies::CUCUMBER as ???\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/modules/modules2.rs:10:31\n   |\n10 |     use self::fruits::PEAR as ???\n   |                               ^ expected identifier\n\nerror: aborting due to previous error\n\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as ???\n    use self::veggies::CUCUMBER as ???\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected identifier, found `?`\n --> exercises/modules/modules2.rs:9:31\n  |\n9 |     use self::fruits::PEAR as ???\n  |                               ^ expected identifier\n\nerror: aborting due to previous error\n\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit\n    use self::veggies::CUCUMBER as ???\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected `;`, found keyword `use`\n  --> exercises/modules/modules2.rs:9:36\n   |\n9  |     use self::fruits::PEAR as fruit\n   |                                    ^ help: add `;` here\n10 |     use self::veggies::CUCUMBER as ???\n   |     --- unexpected token\n\nerror: expected identifier, found `?`\n  --> exercises/modules/modules2.rs:10:36\n   |\n10 |     use self::veggies::CUCUMBER as ???\n   |                                    ^ expected identifier\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit\n    use self::veggies::CUCUMBER as veggie\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected `;`, found keyword `use`\n  --> exercises/modules/modules2.rs:9:36\n   |\n9  |     use self::fruits::PEAR as fruit\n   |                                    ^ help: add `;` here\n10 |     use self::veggies::CUCUMBER as veggie\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `mod`\n  --> exercises/modules/modules2.rs:10:42\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |                                          ^ help: add `;` here\n11 |\n12 |     mod fruits {\n   |     --- unexpected token\n\nerror[E0603]: constant import `fruit` is private\n  --> exercises/modules/modules2.rs:26:27\n   |\n26 |         delicious_snacks::fruit,\n   |                           ^^^^^ private constant import\n   |\nnote: the constant import `fruit` is defined here...\n  --> exercises/modules/modules2.rs:9:9\n   |\n9  |     use self::fruits::PEAR as fruit\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `PEAR` which is defined here\n  --> exercises/modules/modules2.rs:13:9\n   |\n13 |         pub const PEAR: &'static str = \"Pear\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit\n    use self::veggies::CUCUMBER as veggie\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected `;`, found keyword `use`\n  --> exercises/modules/modules2.rs:9:36\n   |\n9  |     use self::fruits::PEAR as fruit\n   |                                    ^ help: add `;` here\n10 |     use self::veggies::CUCUMBER as veggie\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `pub`\n  --> exercises/modules/modules2.rs:10:42\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |                                          ^ help: add `;` here\n11 |\n12 |    pub mod fruits {\n   |    --- unexpected token\n\nerror[E0603]: constant import `fruit` is private\n  --> exercises/modules/modules2.rs:26:27\n   |\n26 |         delicious_snacks::fruit,\n   |                           ^^^^^ private constant import\n   |\nnote: the constant import `fruit` is defined here...\n  --> exercises/modules/modules2.rs:9:9\n   |\n9  |     use self::fruits::PEAR as fruit\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `PEAR` which is defined here\n  --> exercises/modules/modules2.rs:13:9\n   |\n13 |         pub const PEAR: &'static str = \"Pear\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit;\n    use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error[E0603]: constant import `fruit` is private\n  --> exercises/modules/modules2.rs:26:27\n   |\n26 |         delicious_snacks::fruit,\n   |                           ^^^^^ private constant import\n   |\nnote: the constant import `fruit` is defined here...\n  --> exercises/modules/modules2.rs:9:9\n   |\n9  |     use self::fruits::PEAR as fruit;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `PEAR` which is defined here\n  --> exercises/modules/modules2.rs:13:9\n   |\n13 |         pub const PEAR: &'static str = \"Pear\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n    use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}

{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse ???\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/modules/modules3.rs:11:5\n   |\n11 | use ???\n   |     ^ expected identifier\n\nerror: aborting due to previous error\n\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:14\n   |\n11 | use std::time\n   |              ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared type `SystemTime`\n  --> exercises/modules/modules3.rs:14:11\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |           ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n11 | use time::SystemTime;\n   |\n\nerror[E0425]: cannot find value `UNIX_EPOCH` in this scope\n  --> exercises/modules/modules3.rs:14:44\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |                                            ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this constant\n   |\n11 | use time::UNIX_EPOCH;\n   |\n\nwarning: unused import: `std::time`\n  --> exercises/modules/modules3.rs:11:5\n   |\n11 | use std::time\n   |     ^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time::{}\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:18\n   |\n11 | use std::time::{}\n   |                  ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared type `SystemTime`\n  --> exercises/modules/modules3.rs:14:11\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |           ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n11 | use _::SystemTime;\n   |\n\nerror[E0425]: cannot find value `UNIX_EPOCH` in this scope\n  --> exercises/modules/modules3.rs:14:44\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |                                            ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this constant\n   |\n11 | use _::UNIX_EPOCH;\n   |\n\nwarning: unused import: `std::time::{}`\n  --> exercises/modules/modules3.rs:11:5\n   |\n11 | use std::time::{}\n   |     ^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime}\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:28\n   |\n11 | use std::time::{SystemTime}\n   |                            ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror[E0425]: cannot find value `UNIX_EPOCH` in this scope\n  --> exercises/modules/modules3.rs:14:44\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |                                            ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this constant\n   |\n11 | use std::time::UNIX_EPOCH;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH}\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:39\n   |\n11 | use std::time::{SystemTime,UNIX_EPOCH}\n   |                                       ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}

{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        fruit.\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         fruit.\n   |         ^^^^^ expected `()`, found enum `Fruit`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        fruit.entry().\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0599]: no method named `entry` found for enum `Fruit` in the current scope\n  --> exercises/hashmaps/hashmaps2.rs:37:15\n   |\n18 | enum Fruit {\n   | ---------- method `entry` not found for this enum\n...\n37 |         fruit.entry().\n   |               ^^^^^ method not found in `Fruit`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        bak.entry().\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0425]: cannot find value `bak` in this scope\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         bak.entry().\n   |         ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry().\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> exercises/hashmaps/hashmaps2.rs:37:16\n    |\n37  |         basket.entry().\n    |                ^^^^^-- an argument of type `Fruit` is missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:854:12\n    |\n854 |     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n    |            ^^^^^\nhelp: provide the argument\n    |\n37  |         basket.entry(/* Fruit */).\n    |                     ~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry().\n   |         ^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found enum `std::collections::hash_map::Entry`\n   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_, Fruit, u32>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(f).\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0425]: cannot find value `f` in this scope\n  --> exercises/hashmaps/hashmaps2.rs:37:22\n   |\n37 |         basket.entry(f).\n   |                      ^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry(f).\n   |         ^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found enum `std::collections::hash_map::Entry`\n   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_, Fruit, u32>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry(fruit).\n   |         ^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found enum `std::collections::hash_map::Entry`\n   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_, Fruit, u32>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error[E0609]: no field `or` on type `std::collections::hash_map::Entry<'_, Fruit, u32>`\n  --> exercises/hashmaps/hashmaps2.rs:37:29\n   |\n37 |         basket.entry(fruit).or\n   |                             ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert()\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> exercises/hashmaps/hashmaps2.rs:37:29\n     |\n37   |         basket.entry(fruit).or_insert()\n     |                             ^^^^^^^^^-- an argument of type `u32` is missing\n     |\nnote: associated function defined here\n    --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:2533:12\n     |\n2533 |     pub fn or_insert(self, default: V) -> &'a mut V {\n     |            ^^^^^^^^^\nhelp: provide the argument\n     |\n37   |         basket.entry(fruit).or_insert(/* u32 */)\n     |                                      ~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry(fruit).or_insert()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found `&mut u32`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert();\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> exercises/hashmaps/hashmaps2.rs:37:29\n     |\n37   |         basket.entry(fruit).or_insert();\n     |                             ^^^^^^^^^-- an argument of type `u32` is missing\n     |\nnote: associated function defined here\n    --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:2533:12\n     |\n2533 |     pub fn or_insert(self, default: V) -> &'a mut V {\n     |            ^^^^^^^^^\nhelp: provide the argument\n     |\n37   |         basket.entry(fruit).or_insert(/* u32 */);\n     |                                      ~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}

{"wrong_code": "// strings2.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let word = String::from(\"green\"); // Try not changing this line :)\n    if is_a_color_word(word) {\n        println!(\"That is a color word I know!\");\n    } else {\n        println!(\"That is not a color word I know.\");\n    }\n}\n\nfn is_a_color_word(attempt: &str) -> bool {\n    attempt == \"green\" || attempt == \"blue\" || attempt == \"red\"\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/strings/strings2.rs:9:24\n   |\n9  |     if is_a_color_word(word) {\n   |        --------------- ^^^^\n   |        |               |\n   |        |               expected `&str`, found struct `String`\n   |        |               help: consider borrowing here: `&word`\n   |        arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/strings/strings2.rs:16:4\n   |\n16 | fn is_a_color_word(attempt: &str) -> bool {\n   |    ^^^^^^^^^^^^^^^ -------------\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// strings2.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let word = String::from(\"green\"); // Try not changing this line :)\n    if is_a_color_word(&word) {\n        println!(\"That is a color word I know!\");\n    } else {\n        println!(\"That is not a color word I know.\");\n    }\n}\n\nfn is_a_color_word(attempt: &str) -> bool {\n    attempt == \"green\" || attempt == \"blue\" || attempt == \"red\"\n}\n"}

