{"wrong_code": "// variables1.rs\n// Make me compile!\n// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    x = 5;\n    println!(\"x has the value {}\", x);\n}\n", "error": "error[E0425]: cannot find value `x` in this scope\n --> exercises/variables/variables1.rs:8:5\n  |\n8 |     x = 5;\n  |     ^ not found in this scope\n\nerror[E0425]: cannot find value `x` in this scope\n --> exercises/variables/variables1.rs:9:36\n  |\n9 |     println!(\"x has the value {}\", x);\n  |                                    ^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// variables1.rs\n// Make me compile!\n// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x = 5;\n    println!(\"x has the value {}\", x);\n}\n"}

{"wrong_code": "// variables2.rs\n// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let x;\n    if x == 10 {\n        println!(\"x is ten!\");\n    } else {\n        println!(\"x is not ten!\");\n    }\n}\n", "error": "error[E0282]: type annotations needed\n --> exercises/variables/variables2.rs:7:9\n  |\n7 |     let x;\n  |         ^\n  |\nhelp: consider giving `x` an explicit type\n  |\n7 |     let x: _;\n  |          +++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// variables2.rs\n// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x=10;\n    if x == 10 {\n        println!(\"x is ten!\");\n    } else {\n        println!(\"x is not ten!\");\n    }\n}\n"}

{"wrong_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let x: i32;\n    println!(\"Number {}\", x);\n}\n", "error": "error[E0381]: used binding `x` isn't initialized\n --> exercises/variables/variables3.rs:8:27\n  |\n7 |     let x: i32;\n  |         - binding declared here but left uninitialized\n8 |     println!(\"Number {}\", x);\n  |                           ^ `x` used here but it isn't initialized\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0381`.\n", "right_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x: i32=1;\n    println!(\"Number {}\", x);\n}\n"}
{"wrong_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x: i32=1-;\n    println!(\"Number {}\", x);\n}\n", "error": "error: expected expression, found `;`\n --> exercises/variables/variables3.rs:7:18\n  |\n7 |     let x: i32=1-;\n  |                  ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// variables3.rs\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let x: i32=1;\n    println!(\"Number {}\", x);\n}\n"}

{"wrong_code": "// variables4.rs\n// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let x = 3;\n    println!(\"Number {}\", x);\n    x = 5; // don't change this line\n    println!(\"Number {}\", x);\n}\n", "error": "error[E0384]: cannot assign twice to immutable variable `x`\n --> exercises/variables/variables4.rs:9:5\n  |\n7 |     let x = 3;\n  |         -\n  |         |\n  |         first assignment to `x`\n  |         help: consider making this binding mutable: `mut x`\n8 |     println!(\"Number {}\", x);\n9 |     x = 5; // don't change this line\n  |     ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n", "right_code": "// variables4.rs\n// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let mut x = 3;\n    println!(\"Number {}\", x);\n    x = 5; // don't change this line\n    println!(\"Number {}\", x);\n}\n"}

{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n", "error": "error[E0425]: cannot find function `call_me` in this scope\n --> exercises/functions/functions1.rs:7:5\n  |\n7 |     call_me();\n  |     ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_m", "error": "error: expected one of `(` or `<`, found `<eof>`\n  --> exercises/functions/functions1.rs:10:4\n   |\n10 | fn call_m\n   |    ^^^^^^ expected one of `(` or `<`\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    ", "error": "error: this file contains an unclosed delimiter\n  --> exercises/functions/functions1.rs:11:5\n   |\n10 | fn call_me() { \n   |              - unclosed delimiter\n11 |     \n   |     ^\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!()", "error": "error: this file contains an unclosed delimiter\n  --> exercises/functions/functions1.rs:11:15\n   |\n10 | fn call_me() { \n   |              - unclosed delimiter\n11 |     println!()\n   |               ^\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(hello\")", "error": "error[E0765]: unterminated double quote string\n  --> exercises/functions/functions1.rs:11:19\n   |\n11 |     println!(hello\")\n   |                   ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}
{"wrong_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")", "error": "error: this file contains an unclosed delimiter\n  --> exercises/functions/functions1.rs:11:22\n   |\n10 | fn call_me() { \n   |              - unclosed delimiter\n11 |     println!(\"hello\")\n   |                      ^\n\nerror: aborting due to previous error\n\n", "right_code": "// functions1.rs\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me();\n}\n \nfn call_me() { \n    println!(\"hello\")\n}"}

{"wrong_code": "// functions2.rs\n// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n", "error": "error: expected type, found `)`\n  --> exercises/functions/functions2.rs:10:16\n   |\n10 | fn call_me(num:) {\n   |                ^ expected type\n\nerror[E0425]: cannot find value `num` in this scope\n  --> exercises/functions/functions2.rs:11:17\n   |\n11 |     for i in 0..num {\n   |                 ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// functions2.rs\n// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:i32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n"}

{"wrong_code": "// functions3.rs\n// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n\nfn call_me(num: u32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n", "error": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n  --> exercises/functions/functions3.rs:7:5\n   |\n7  |     call_me();\n   |     ^^^^^^^-- an argument of type `u32` is missing\n   |\nnote: function defined here\n  --> exercises/functions/functions3.rs:10:4\n   |\n10 | fn call_me(num: u32) {\n   |    ^^^^^^^ --------\nhelp: provide the argument\n   |\n7  |     call_me(/* u32 */);\n   |            ~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// functions3.rs\n// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num: u32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n"}

{"wrong_code": "// functions4.rs\n// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.\n\n// This store is having a sale where if the price is an even number, you get\n// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n// I AM NOT DONE\n\nfn main() {\n    let original_price = 51;\n    println!(\"Your sale price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: i32) -> {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: i32) -> bool {\n    num % 2 == 0\n}\n", "error": "error: expected type, found `{`\n  --> exercises/functions/functions4.rs:17:30\n   |\n17 | fn sale_price(price: i32) -> {\n   |                              ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// functions4.rs\n// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.\n\n// This store is having a sale where if the price is an even number, you get\n// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\nfn main() {\n    let original_price = 51;\n    println!(\"Your sale price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: i32) -> i32{\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: i32) -> bool {\n    num % 2 == 0\n}\n"}

{"wrong_code": "// functions5.rs\n// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let answer = square(3);\n    println!(\"The square of 3 is {}\", answer);\n}\n\nfn square(num: i32) -> i32 {\n    num * num;\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/functions/functions5.rs:11:24\n   |\n11 | fn square(num: i32) -> i32 {\n   |    ------              ^^^ expected `i32`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n12 |     num * num;\n   |              - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// functions5.rs\n// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = square(3);\n    println!(\"The square of 3 is {}\", answer);\n}\n\nfn square(num: i32) -> i32 {\n    num * num\n}\n"}

{"wrong_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn bigger(a: i32, b: i32) -> i32 {\n    // Complete this function to return the bigger number!\n    // Do not use:\n    // - another function call\n    // - additional variables\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n", "error": "error[E0308]: mismatched types\n --> exercises/if/if1.rs:6:34\n  |\n6 | pub fn bigger(a: i32, b: i32) -> i32 {\n  |        ------                    ^^^ expected `i32`, found `()`\n  |        |\n  |        implicitly returns `()` as its body has no tail or `return` expression\n  |\nnote: consider returning one of these bindings\n --> exercises/if/if1.rs:6:15\n  |\n6 | pub fn bigger(a: i32, b: i32) -> i32 {\n  |               ^       ^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n   else \n   {\n    b\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n"}
{"wrong_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n", "error": "error: expected `{`, found `}`\n --> exercises/if/if1.rs:8:1\n  |\n8 | }\n  | ^ expected `{`\n  |\nnote: the `if` expression is missing a block after this condition\n --> exercises/if/if1.rs:7:7\n  |\n7 |    if a\n  |       ^\n\nerror: aborting due to previous error\n\n", "right_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n   else \n   {\n    b\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n"}
{"wrong_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n", "error": "error[E0317]: `if` may be missing an `else` clause\n --> exercises/if/if1.rs:7:4\n  |\n6 |   pub fn bigger(a: i32, b: i32) -> i32 {\n  |                                    --- expected `i32` because of this return type\n7 | /    if a>b {\n8 | |     a\n9 | |    }\n  | |____^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0317`.\n", "right_code": "// if1.rs\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -> i32 {\n   if a>b {\n    a\n   }\n   else \n   {\n    b\n   }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n}\n"}

{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else {\n        1\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/if/if2.rs:13:9\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                      ---- expected `&str` because of return type\n...\n13 |         1\n   |         ^ expected `&str`, found integer\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if{\n        1\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: missing condition for `if` expression\n  --> exercises/if/if2.rs:12:14\n   |\n12 |     } else if{\n   |              ^\n   |              |\n   |              expected condition here\n   |              if this block is the condition of the `if` expression, then it must be followed by another block\n\nerror[E0308]: mismatched types\n  --> exercises/if/if2.rs:13:9\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                      ---- expected `&str` because of return type\n...\n13 |         1\n   |         ^ expected `&str`, found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz(\"literally anything\n        1\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/if/if2.rs:34:59\n   |\n34 |           assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n   |  ___________________________________________________________^\n35 | |     }\n36 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz(\"literally anything\n        \n    foo_if_fizz(\"fuzz\")\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/if/if2.rs:35:59\n   |\n35 |           assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n   |  ___________________________________________________________^\n36 | |     }\n37 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz(\"literally anything\n        \n    else if fizzish=\"fuzz\"{\n        \n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/if/if2.rs:37:59\n   |\n37 |           assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n   |  ___________________________________________________________^\n38 | |     }\n39 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=literally anything\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:18:1\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n17 |     }\n   |     - ...matches this closing brace\n18 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \n    }\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:21:1\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n20 |     }\n   |     - ...matches this closing brace\n21 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } else {\n        &fizzish\n    }\n}\n\n    }\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:20:5\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n18 | }\n   | - ...matches this closing brace\n19 |\n20 |     }\n   |     ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } \n}\n\n    }\n        \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:18:5\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n16 | }\n   | - ...matches this closing brace\n17 |\n18 |     }\n   |     ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n}\n\n    }\n        \n   \n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/if/if2.rs:21:5\n   |\n9  | pub fn foo_if_fizz(fizzish: &str) -> &str {\n   |                                           - this opening brace...\n...\n19 | }\n   | - ...matches this closing brace\n20 |\n21 |     }\n   |     ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"bar\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"foo\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz=\"literally anything\"\n   |               ^^^^ not found in this scope\n   |\nhelp: you might have meant to use pattern matching\n   |\n12 |     } else if let fizz=\"literally anything\"\n   |               +++\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> exercises/if/if2.rs:16:10\n   |\n16 |       else if fizzish==\"fuzz\" {\n   |  __________^\n17 | |         \"foo\"\n   | |         ----- found here\n18 | |     }\n   | |_____^ expected `()`, found `&str`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz=\"literally anything\"\n    {\n        \"baz\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz=\"literally anything\"\n   |               ^^^^ not found in this scope\n   |\nhelp: you might have meant to use pattern matching\n   |\n12 |     } else if let fizz=\"literally anything\"\n   |               +++\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> exercises/if/if2.rs:16:10\n   |\n16 |       else if fizzish==\"fuzz\" {\n   |  __________^\n17 | |         \"bar\"\n   | |         ----- found here\n18 | |     }\n   | |_____^ expected `()`, found `&str`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else if fizzish==\"fuzz\" {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz==\"literally anything\"\n   |               ^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> exercises/if/if2.rs:16:10\n   |\n16 |       else if fizzish==\"fuzz\" {\n   |  __________^\n17 | |         \"bar\"\n   | |         ----- found here\n18 | |     }\n   | |_____^ expected `()`, found `&str`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}
{"wrong_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizz==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n", "error": "error[E0425]: cannot find value `fizz` in this scope\n  --> exercises/if/if2.rs:12:15\n   |\n12 |     } else if fizz==\"literally anything\"\n   |               ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// if2.rs\n\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\n\npub fn foo_if_fizz(fizzish: &str) -> &str {\n    if fizzish == \"fizz\" {\n        \"foo\"\n    } else if fizzish==\"literally anything\"\n    {\n        \"baz\"\n    } \n    else  {\n        \"bar\"\n    }\n}\n\n    \n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n"}

{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\n", "error": "error[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:21:18\n   |\n21 |     let price1 = calculate_price_of_apples(35);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:22:18\n   |\n22 |     let price2 = calculate_price_of_apples(40);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:23:18\n   |\n23 |     let price3 = calculate_price_of_apples(41);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calculate_price_of_apples` in this scope\n  --> exercises/quiz1.rs:24:18\n   |\n24 |     let price4 = calculate_price_of_apples(65);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(35)", "error": "error: expected one of `...`, `..=`, `..`, `:`, or `|`, found `)`\n  --> exercises/quiz1.rs:31:32\n   |\n31 | fn calculate_price_of_apples(35)\n   |                                ^ expected one of `...`, `..=`, `..`, `:`, or `|`\n\nerror: expected one of `->`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:32\n   |\n31 | fn calculate_price_of_apples(35)\n   |                                ^ expected one of `->`, `where`, or `{`\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples()", "error": "error: expected one of `->`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:30\n   |\n31 | fn calculate_price_of_apples()\n   |                              ^ expected one of `->`, `where`, or `{`\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)", "error": "error: expected one of `->`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:35\n   |\n31 | fn calculate_price_of_apples(a:i32)\n   |                                   ^ expected one of `->`, `where`, or `{`\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32", "error": "error: expected one of `!`, `(`, `+`, `::`, `<`, `where`, or `{`, found `<eof>`\n  --> exercises/quiz1.rs:31:38\n   |\n31 | fn calculate_price_of_apples(a:i32)->i32\n   |                                      ^^^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    \n}", "error": "error[E0308]: mismatched types\n  --> exercises/quiz1.rs:31:38\n   |\n31 | fn calculate_price_of_apples(a:i32)->i32{\n   |    -------------------------         ^^^ expected `i32`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\nhelp: consider returning the local binding `a`\n   |\n31 ~ fn calculate_price_of_apples(a:i32)->i32{\n32 +     a\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a\n}", "error": "error: expected `{`, found `}`\n  --> exercises/quiz1.rs:32:1\n   |\n32 | }\n   | ^ expected `{`\n   |\nnote: the `if` expression is missing a block after this condition\n  --> exercises/quiz1.rs:31:8\n   |\n31 |     if a\n   |        ^\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40\n}", "error": "error: expected `{`, found `}`\n  --> exercises/quiz1.rs:32:1\n   |\n32 | }\n   | ^ expected `{`\n   |\nnote: the `if` expression is missing a block after this condition\n  --> exercises/quiz1.rs:31:8\n   |\n31 |     if a>40\n   |        ^^^^\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n}", "error": "error[E0317]: `if` may be missing an `else` clause\n  --> exercises/quiz1.rs:31:5\n   |\n30 |   fn calculate_price_of_apples(a:i32)->i32{\n   |                                        --- expected `i32` because of this return type\n31 | /     if a>40{\n32 | |         a\n33 | |     }\n   | |_____^ expected `i32`, found `()`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0317`.\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}
{"wrong_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n}", "error": "error: expected `{`, found `}`\n  --> exercises/quiz1.rs:35:1\n   |\n35 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n", "right_code": "// quiz1.rs\n// This is a quiz for the following sections:\n// - Variables\n// - Functions\n// - If\n\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 2 rustbucks.\n// - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n\n// Put your function here!\n// fn calculate_price_of_apples {\n\n// Don't modify this function!\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert_eq!(70, price1);\n    assert_eq!(80, price2);\n    assert_eq!(41, price3);\n    assert_eq!(65, price4);\n}\nfn calculate_price_of_apples(a:i32)->i32{\n    if a>40{\n        a\n    }\n    else \n    {\n        a*2\n    }\n}"}

{"wrong_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let // Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n", "error": "error: expected identifier, found keyword `if`\n  --> exercises/primitive_types/primitive_types1.rs:16:5\n   |\n16 |     if is_evening {\n   |     ^^ expected identifier, found keyword\n\nerror: expected one of `:`, `;`, `=`, `@`, or `|`, found `is_evening`\n  --> exercises/primitive_types/primitive_types1.rs:16:8\n   |\n16 |     if is_evening {\n   |        ^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening=true;// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n", "error": "error: expected `;`, found keyword `if`\n  --> exercises/primitive_types/primitive_types1.rs:15:19\n   |\n15 |     let is_evening// Finish the rest of this line like the example! Or make it be false!\n   |                   ^ help: add `;` here\n16 |     if is_evening {\n   |     -- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types1.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening=true;// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n"}

{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error: expected identifier, found keyword `if`\n  --> exercises/primitive_types/primitive_types2.rs:24:5\n   |\n24 |     if your_character.is_alphabetic() {\n   |     ^^ expected identifier, found keyword\n\nerror: expected one of `:`, `;`, `=`, `@`, or `|`, found `your_character`\n  --> exercises/primitive_types/primitive_types2.rs:24:8\n   |\n24 |     if your_character.is_alphabetic() {\n   |        ^^^^^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=// Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/primitive_types/primitive_types2.rs:30:6\n   |\n30 |     }\n   |      ^ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `your_character` in this scope\n  --> exercises/primitive_types/primitive_types2.rs:24:8\n   |\n24 |     if your_character.is_alphabetic() {\n   |        ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `your_character` in this scope\n  --> exercises/primitive_types/primitive_types2.rs:26:15\n   |\n26 |     } else if your_character.is_numeric() {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=1 // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error: expected `;`, found keyword `if`\n  --> exercises/primitive_types/primitive_types2.rs:21:25\n   |\n21 |     let your_character=1 // Finish this line like the example! What's your favorite character?\n   |                         ^ help: add `;` here\n...\n24 |     if your_character.is_alphabetic() {\n   |     -- unexpected token\n\nerror[E0599]: no method named `is_alphabetic` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:24:23\n   |\n24 |     if your_character.is_alphabetic() {\n   |                       ^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_numeric` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:26:30\n   |\n26 |     } else if your_character.is_numeric() {\n   |                              ^^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=1 ;// Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error[E0599]: no method named `is_alphabetic` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:24:23\n   |\n24 |     if your_character.is_alphabetic() {\n   |                       ^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_numeric` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:26:30\n   |\n26 |     } else if your_character.is_numeric() {\n   |                              ^^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=1 ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error[E0599]: no method named `is_alphabetic` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:25:23\n   |\n25 |     if your_character.is_alphabetic() {\n   |                       ^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_numeric` found for type `{integer}` in the current scope\n  --> exercises/primitive_types/primitive_types2.rs:27:30\n   |\n27 |     } else if your_character.is_numeric() {\n   |                              ^^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}
{"wrong_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character=\" ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/primitive_types/primitive_types2.rs:30:50\n   |\n30 |           println!(\"Neither alphabetic nor numeric!\");\n   |  __________________________________________________^\n31 | |     }\n32 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// primitive_types2.rs\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character='a' ;\n    // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n"}

{"wrong_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let a = ???\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n", "error": "error: expected expression, found `?`\n --> exercises/primitive_types/primitive_types3.rs:8:13\n  |\n8 |     let a = ???\n  |             ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let a = \"hhhh\";\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n"}
{"wrong_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let a = \"\"\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n", "error": "error: expected `;`, found keyword `if`\n  --> exercises/primitive_types/primitive_types3.rs:8:15\n   |\n8  |     let a = \"\"\n   |               ^ help: add `;` here\n9  |\n10 |     if a.len() >= 100 {\n   |     -- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types3.rs\n// Create an array with at least 100 elements in it where the ??? is.\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let a = \"hhhh\";\n\n    if a.len() >= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n    }\n}\n"}

{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = ???\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/primitive_types/primitive_types4.rs:11:22\n   |\n11 |     let nice_slice = ???\n   |                      ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = ???\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/primitive_types/primitive_types4.rs:10:22\n   |\n10 |     let nice_slice = ???\n   |                      ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1]\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = a[1]\n   |                          ^ help: add `;` here\n11 |\n12 |     assert_eq!([2, 3, 4], nice_slice)\n   |     --------- unexpected token\n\nerror[E0277]: can't compare `[{integer}; 3]` with `{integer}`\n  --> exercises/primitive_types/primitive_types4.rs:12:5\n   |\n12 |     assert_eq!([2, 3, 4], nice_slice)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `[{integer}; 3] == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `[{integer}; 3]`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n           and 3 others\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[]\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: expected expression, found `]`\n  --> exercises/primitive_types/primitive_types4.rs:10:24\n   |\n10 |     let nice_slice = a[]\n   |                        ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3...5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[3...5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[3..5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[3..=5];\n   |                         ~~~\n\nerror[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[3...5];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[3...5];\n   |                      +\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3..5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[3..5];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[3..5];\n   |                      +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3.5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error[E0277]: the type `[{integer}]` cannot be indexed by `{float}`\n  --> exercises/primitive_types/primitive_types4.rs:10:24\n   |\n10 |     let nice_slice = a[3.5];\n   |                        ^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `{float}`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required for `[{integer}]` to implement `Index<{float}>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[3....5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[3....5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[3...5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[3..=.5];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[3....5];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[3....5];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[2....5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[2....5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[2...5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[2..=.5];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[2....5];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[2....5];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1....5];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....5];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1...5];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=.5];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....5];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[1....5];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1....3];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....3];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1...3];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=.3];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....3];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[1....3];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1....4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....4];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1...4];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=.4];\n   |                         ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1....4];\n   |                         ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:28\n   |\n10 |     let nice_slice = a[1....4];\n   |                            ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1...4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:25\n   |\n10 |     let nice_slice = a[1...4];\n   |                         ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = a[1..4];\n   |                         ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = a[1..=4];\n   |                         ~~~\n\nerror[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[1...4];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[1...4];\n   |                      +\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n  --> exercises/primitive_types/primitive_types4.rs:10:9\n   |\n10 |     let nice_slice = a[1..4];\n   |         ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[{integer}]`\n   = note: all local variables must have a statically known size\n   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n   |\n10 |     let nice_slice = &a[1..4];\n   |                      +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1....4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = &a[1....4];\n   |                          ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = &a[1...4];\n   |                          ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = &a[1..=.4];\n   |                          ~~~\n\nerror[E0586]: inclusive range with no end\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = &a[1....4];\n   |                          ^^^ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\nerror: expected `]`, found `.`\n  --> exercises/primitive_types/primitive_types4.rs:10:29\n   |\n10 |     let nice_slice = &a[1....4];\n   |                             ^ expected `]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0586`.\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}
{"wrong_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1...4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n", "error": "error: unexpected token: `...`\n  --> exercises/primitive_types/primitive_types4.rs:10:26\n   |\n10 |     let nice_slice = &a[1...4];\n   |                          ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n10 |     let nice_slice = &a[1..4];\n   |                          ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     let nice_slice = &a[1..=4];\n   |                          ~~~\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types4.rs\n// Get a slice out of Array a where the ??? is so that the test passes.\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n"}

{"wrong_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let /* your pattern here */ = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n", "error": "error: expected pattern, found `=`\n --> exercises/primitive_types/primitive_types5.rs:9:33\n  |\n9 |     let /* your pattern here */ = cat;\n  |                                 ^ expected pattern\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let (name,age) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n"}
{"wrong_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let (name) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n", "error": "error[E0425]: cannot find value `age` in this scope\n  --> exercises/primitive_types/primitive_types5.rs:11:43\n   |\n11 |     println!(\"{} is {} years old.\", name, age);\n   |                                           ^^^ not found in this scope\n\nwarning: unnecessary parentheses around pattern\n --> exercises/primitive_types/primitive_types5.rs:9:9\n  |\n9 |     let (name) = cat;\n  |         ^    ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n9 -     let (name) = cat;\n9 +     let name = cat;\n  |\n\nerror[E0277]: `(&str, {float})` doesn't implement `std::fmt::Display`\n  --> exercises/primitive_types/primitive_types5.rs:11:37\n   |\n11 |     println!(\"{} is {} years old.\", name, age);\n   |                                     ^^^^ `(&str, {float})` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `(&str, {float})`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n", "right_code": "// primitive_types5.rs\n// Destructure the `cat` tuple so that the println will work.\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let cat = (\"Furry McFurson\", 3.5);\n    let (name,age) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n"}

{"wrong_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second = ???;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/primitive_types/primitive_types6.rs:12:18\n   |\n12 |     let second = ???;\n   |                  ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second =2;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n"}
{"wrong_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second =\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/primitive_types/primitive_types6.rs:15:52\n   |\n15 |         \"This is not the 2nd number in the tuple!\")\n   |                                                    ^ help: add `;` here\n16 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `second` in this scope\n  --> exercises/primitive_types/primitive_types6.rs:14:19\n   |\n14 |     assert_eq!(2, second,\n   |                   ^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// primitive_types6.rs\n// Use a tuple index to access the second element of `numbers`.\n// You can put the expression for the second element where ??? is so that the test passes.\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.\n\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second =2;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n"}

{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = // TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/vecs/vecs1.rs:13:11\n   |\n13 |     (a, v)\n   |           ^ help: add `;` here\n14 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v)\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\nhelp: consider returning the local binding `v`\n  |\n13~     (a, v)\n14+     v\n  |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = // TODO: declare your vector here with the macro for vectors\n\n    (a, v);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v);\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\nhelp: consider returning the local binding `v`\n  |\n13~     (a, v);\n14+     v\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec!// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/vecs/vecs1.rs:13:11\n   |\n13 |     (a, v)\n   |           ^ help: add `;` here\n14 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v)\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> exercises/vecs/vecs1.rs:14:1\n   |\n14 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/vecs/vecs1.rs:11:17\n   |\n9  | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n   |                                            - closing delimiter possibly meant for this\n10 |     let a = [10, 20, 30, 40]; // a plain array\n11 |     let v = vec![// TODO: declare your vector here with the macro for vectors\n   |                 ^ unclosed delimiter\n...\n14 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}
{"wrong_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![1,2,3,4]// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n", "error": "error: expected `;`, found `}`\n  --> exercises/vecs/vecs1.rs:13:11\n   |\n13 |     (a, v)\n   |           ^ help: add `;` here\n14 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `v` in this scope\n  --> exercises/vecs/vecs1.rs:13:9\n   |\n13 |     (a, v)\n   |         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0618]: expected function, found `Vec<{integer}>`\n  --> exercises/vecs/vecs1.rs:11:13\n   |\n11 |       let v = vec![1,2,3,4]// TODO: declare your vector here with the macro for vectors\n   |               -^^^^^^^^^^^^\n   |               |\n   |  _____________help: consider using a semicolon here: `;`\n   | |\n12 | |\n13 | |     (a, v)\n   | |__________- call expression requires function\n   |\n   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> exercises/vecs/vecs1.rs:9:23\n  |\n9 | fn array_and_vec() -> ([i32; 4], Vec<i32>) {\n  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note:  expected tuple `([i32; 4], Vec<i32>)`\n          found unit type `()`\nhelp: consider returning the local binding `v`\n  |\n13~     (a, v)\n14+     v\n  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0618.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// vecs1.rs\n// Your task is to create a `Vec` which holds the exact same elements\n// as in the array `a`.\n// Make me compile and pass the test!\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn array_and_vec() -> ([i32; 4], Vec<i32>) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10,20,30,40];// TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n"}

{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        ???\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         ???\n   |         ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        * i\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         * i\n   |         ^^^ expected `()`, found `i32`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*2\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         *i*2\n   |         ^^^^ expected `()`, found `i32`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> exercises/vecs/vecs2.rs:15:9\n   |\n15 |         *i\n   |         ^^ expected `()`, found `i32`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: unknown start of token: \u{ff1b}\n  --> exercises/vecs/vecs2.rs:15:14\n   |\n15 |         *i*=2\n   |              ^^\n   |\nhelp: Unicode character '' (Fullwidth Semicolon) looks like ';' (Semicolon), but it is not\n   |\n15 |         *i*=2;\n   |              ~\n\nerror: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}
{"wrong_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        ???\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/vecs/vecs2.rs:26:9\n   |\n26 |         ???\n   |         ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// vecs2.rs\n// A Vec of even numbers is given. Your task is to complete the loop\n// so that each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn vec_loop(mut v: Vec<i32>) -> Vec<i32> {\n    for i in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *i*=2;\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &Vec<i32>) -> Vec<i32> {\n    v.iter().map(|num| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        num*2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());\n    }\n}\n"}

{"wrong_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec1` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:13:5\n   |\n9  |     let vec1 = fill_vec(vec0);\n   |         ---- help: consider changing this to be mutable: `mut vec1`\n...\n13 |     vec1.push(88);\n   |     ^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: mut Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error: expected type, found keyword `mut`\n  --> exercises/move_semantics/move_semantics1.rs:18:18\n   |\n18 | fn fill_vec(vec: mut Vec<i32>) -> Vec<i32> {\n   |                  ^^^ expected type\n\nerror[E0423]: expected value, found macro `vec`\n  --> exercises/move_semantics/move_semantics1.rs:19:19\n   |\n19 |     let mut vec = vec;\n   |                   ^^^ not a value\n\nerror[E0282]: type annotations needed for `Vec<T>`\n --> exercises/move_semantics/move_semantics1.rs:7:9\n  |\n7 |     let vec0 = Vec::new();\n  |         ^^^^\n  |\nhelp: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified\n  |\n7 |     let vec0: Vec<T> = Vec::new();\n  |             ++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0282, E0423.\nFor more information about an error, try `rustc --explain E0282`.\n", "right_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let  vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:21:5\n   |\n19 |     let  vec = vec;\n   |          --- help: consider changing this to be mutable: `mut vec`\n20 |\n21 |     vec.push(22);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:22:5\n   |\n19 |     let  vec = vec;\n   |          --- help: consider changing this to be mutable: `mut vec`\n...\n22 |     vec.push(44);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics1.rs:23:5\n   |\n19 |     let  vec = vec;\n   |          --- help: consider changing this to be mutable: `mut vec`\n...\n23 |     vec.push(66);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics1.rs\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0382]: borrow of moved value: `vec0`\n  --> exercises/move_semantics/move_semantics2.rs:13:57\n   |\n8  |     let vec0 = Vec::new();\n   |         ---- move occurs because `vec0` has type `Vec<i32>`, which does not implement the `Copy` trait\n9  |\n10 |     let mut vec1 = fill_vec(vec0);\n   |                             ---- value moved here\n...\n13 |     println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n   |                                                         ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0.clone());\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0382]: borrow of moved value: `vec0`\n  --> exercises/move_semantics/move_semantics2.rs:11:57\n   |\n6  |     let vec0 = Vec::new();\n   |         ---- move occurs because `vec0` has type `Vec<i32>`, which does not implement the `Copy` trait\n7  |\n8  |     let mut vec1 = fill_vec(vec0);\n   |                             ---- value moved here\n...\n11 |     println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n   |                                                         ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0.clone());\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0).clone();\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0382]: borrow of moved value: `vec0`\n  --> exercises/move_semantics/move_semantics2.rs:11:57\n   |\n6  |     let vec0 = Vec::new();\n   |         ---- move occurs because `vec0` has type `Vec<i32>`, which does not implement the `Copy` trait\n7  |\n8  |     let mut vec1 = fill_vec(vec0).clone();\n   |                             ---- value moved here\n...\n11 |     println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n   |                                                         ^^^^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics2.rs\n// Make me compile without changing line 13 or moving line 10!\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0.clone());\n\n    // Do not change the following line!\n    println!(\"{} has length {} content `{:?}`\", \"vec0\", vec0.len(), vec0);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:21:5\n   |\n20 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n21 |     vec.push(22);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:22:5\n   |\n20 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n21 |     vec.push(22);\n22 |     vec.push(44);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:23:5\n   |\n20 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n...\n23 |     vec.push(66);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:20:5\n   |\n19 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n20 |     vec.push(22);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:21:5\n   |\n19 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n20 |     vec.push(22);\n21 |     vec.push(44);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics3.rs:22:5\n   |\n19 | fn fill_vec(vec: Vec<i32>) -> Vec<i32> {\n   |             --- help: consider changing this to be mutable: `mut vec`\n...\n22 |     vec.push(66);\n   |     ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics3.rs\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\nfn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec() -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0423]: expected value, found macro `vec`\n  --> exercises/move_semantics/move_semantics4.rs:23:19\n   |\n23 |     let mut vec = vec;\n   |                   ^^^ not a value\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n  --> exercises/move_semantics/move_semantics4.rs:12:20\n   |\n12 |     let mut vec1 = fill_vec(vec0);\n   |                    ^^^^^^^^ ---- argument of type `Vec<_>` unexpected\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics4.rs:22:4\n   |\n22 | fn fill_vec() -> Vec<i32> {\n   |    ^^^^^^^^\nhelp: remove the extra argument\n   |\n12 |     let mut vec1 = fill_vec();\n   |                            ~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0423.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error: expected one of `:`, `@`, or `|`, found `)`\n  --> exercises/move_semantics/move_semantics4.rs:22:16\n   |\n22 | fn fill_vec(vec) -> Vec<i32> {\n   |                ^ expected one of `:`, `@`, or `|`\n   |\n   = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)\nhelp: if this is a `self` type, give it a parameter name\n   |\n22 | fn fill_vec(self: vec) -> Vec<i32> {\n   |             +++++\nhelp: if this is a parameter name, give it a type\n   |\n22 | fn fill_vec(vec: TypeName) -> Vec<i32> {\n   |                ++++++++++\nhelp: if this is a type, explicitly ignore the parameter name\n   |\n22 | fn fill_vec(_: vec) -> Vec<i32> {\n   |             ++\n\nerror[E0282]: type annotations needed for `Vec<T>`\n  --> exercises/move_semantics/move_semantics4.rs:10:9\n   |\n10 |     let vec0 = Vec::new();\n   |         ^^^^\n   |\nhelp: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified\n   |\n10 |     let vec0: Vec<T> = Vec::new();\n   |             ++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}
{"wrong_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:V) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n", "error": "error[E0412]: cannot find type `V` in this scope\n  --> exercises/move_semantics/move_semantics4.rs:22:17\n   |\n22 | fn fill_vec(vec:V) -> Vec<i32> {\n   |            -    ^ not found in this scope\n   |            |\n   |            help: you might be missing a type parameter: `<V>`\n\nerror[E0282]: type annotations needed for `Vec<T>`\n  --> exercises/move_semantics/move_semantics4.rs:10:9\n   |\n10 |     let vec0 = Vec::new();\n   |         ^^^^\n   |\nhelp: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified\n   |\n10 |     let vec0: Vec<T> = Vec::new();\n   |             ++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0412.\nFor more information about an error, try `rustc --explain E0282`.\n", "right_code": "// move_semantics4.rs\n// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,\n// the Vector gets created in the function itself and passed back to the main\n// function.\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let vec0 = Vec::new();\n\n    let mut vec1 = fill_vec(vec0);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n\n    vec1.push(88);\n\n    println!(\"{} has length {} content `{:?}`\", \"vec1\", vec1.len(), vec1);\n}\n\n// `fill_vec()` no longer takes `vec: Vec<i32>` as argument\nfn fill_vec(vec:Vec<i32>) -> Vec<i32> {\n    let mut vec = vec;\n\n    vec.push(22);\n    vec.push(44);\n    vec.push(66);\n\n    vec\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let mut x = 100;\n    let y = &mut x;\n    let z = &mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n11 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n12 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let mut x = 100;\n    let y = mut x;\n    let z = mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error: expected expression, found keyword `mut`\n  --> exercises/move_semantics/move_semantics5.rs:10:13\n   |\n10 |     let y = mut x;\n   |             ^^^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let mut x = 100;\n    let y = & x;\n    let z = & x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "warning: variable does not need to be mutable\n --> exercises/move_semantics/move_semantics5.rs:9:9\n  |\n9 |     let mut x = 100;\n  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0594]: cannot assign to `*y`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:12:5\n   |\n10 |     let y = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n11 |     let z = & x;\n12 |     *y += 100;\n   |     ^^^^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to `*z`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:13:5\n   |\n11 |     let z = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n12 |     *y += 100;\n13 |     *z += 1000;\n   |     ^^^^^^^^^^ `z` is a `&` reference, so the data it refers to cannot be written\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0594`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = & x;\n    let z = & x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0594]: cannot assign to `*y`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:12:5\n   |\n10 |     let y = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n11 |     let z = & x;\n12 |     *y += 100;\n   |     ^^^^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to `*z`, which is behind a `&` reference\n  --> exercises/move_semantics/move_semantics5.rs:13:5\n   |\n11 |     let z = & x;\n   |             --- help: consider changing this to be a mutable reference: `&mut x`\n12 |     *y += 100;\n13 |     *z += 1000;\n   |     ^^^^^^^^^^ `z` is a `&` reference, so the data it refers to cannot be written\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0594`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = & mutx;\n    let z = & x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0425]: cannot find value `mutx` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:10:15\n   |\n10 |     let y = & mutx;\n   |               ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = & mutx;\n    let z = & mutx;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0425]: cannot find value `mutx` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:10:15\n   |\n10 |     let y = & mutx;\n   |               ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `mutx` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:11:15\n   |\n11 |     let z = & mutx;\n   |               ^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = &mut x;\n    let z = &mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:10:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n10 |     let y = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n10 |     let y = &mut x;\n11 |     let z = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n11 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n12 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0499, E0596.\nFor more information about an error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:10:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n10 |     let y = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n9  |     let  x = 100;\n   |          - help: consider changing this to be mutable: `mut x`\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    \n    let z = &mut x;\n    *y += 100;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n14 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0277]: cannot add `()` to `{integer}`\n  --> exercises/move_semantics/move_semantics5.rs:15:8\n   |\n15 |     *y +\n   |        ^ no implementation for `{integer} + ()`\n   |\n   = help: the trait `Add<()>` is not implemented for `{integer}`\n   = help: the following other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +=100\n    assert_eq!(x, 1200);\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/move_semantics/move_semantics5.rs:15:13\n   |\n15 |     *y +=100\n   |             ^ help: add `;` here\n16 |     assert_eq!(x, 1200);\n   |     --------- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +=100\n    assert_eq!(x, 1300);\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/move_semantics/move_semantics5.rs:15:13\n   |\n15 |     *y +=100\n   |             ^ help: add `;` here\n16 |     assert_eq!(x, 1300);\n   |     --------- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    *y +=100;\n    assert_eq!(x, 1300);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n14 |     *z += 1000;\n15 |     *y +=100;\n   |     -------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    \n    *y +=100;\n    *z += 1000;\n    assert_eq!(x, 1300);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:13:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n...\n13 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n14 |     \n15 |     *y +=100;\n   |     -------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}
{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mutx = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0425]: cannot find value `x` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:10:18\n   |\n10 |     let y = &mut x;\n   |                  ^ not found in this scope\n\nerror[E0425]: cannot find value `x` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:13:18\n   |\n13 |     let z = &mut x;\n   |                  ^ help: a local variable with a similar name exists: `y`\n\nerror[E0425]: cannot find value `x` in this scope\n  --> exercises/move_semantics/move_semantics5.rs:15:16\n   |\n15 |     assert_eq!(x, 1200);\n   |                ^ help: a local variable with a similar name exists: `y`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    \n    *y += 100;\n    let z = &mut x;\n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(data);\n\n    string_uppercase(&data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: &String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "warning: variable does not need to be mutable\n --> exercises/move_semantics/move_semantics6.rs:8:9\n  |\n8 |     let mut data = \"Rust is great!\".to_string();\n  |         ----^^^^\n  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved value: `data`\n  --> exercises/move_semantics/move_semantics6.rs:12:22\n   |\n8  |     let mut data = \"Rust is great!\".to_string();\n   |         -------- move occurs because `data` has type `String`, which does not implement the `Copy` trait\n9  |\n10 |     get_char(data);\n   |              ---- value moved here\n11 |\n12 |     string_uppercase(&data);\n   |                      ^^^^^ value borrowed here after move\n\nerror[E0716]: temporary value dropped while borrowed\n  --> exercises/move_semantics/move_semantics6.rs:22:13\n   |\n21 | fn string_uppercase(mut data: &String) {\n   |                               - let's call the lifetime of this reference `'1`\n22 |     data = &data.to_uppercase();\n   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement\n   |     |       |\n   |     |       creates a temporary which is freed while still in use\n   |     assignment requires that borrow lasts for `'1`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0382, E0716.\nFor more information about an error, try `rustc --explain E0382`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}
{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(&data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: &String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:10:14\n   |\n10 |     get_char(&data);\n   |     -------- ^^^^^ expected struct `String`, found `&String`\n   |     |\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:16:4\n   |\n16 | fn get_char(data: String) -> char {\n   |    ^^^^^^^^ ------------\nhelp: consider removing the borrow\n   |\n10 -     get_char(&data);\n10 +     get_char(data);\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}
{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: &String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:10:14\n   |\n10 |     get_char(&data);\n   |     -------- ^^^^^ expected struct `String`, found `&String`\n   |     |\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:16:4\n   |\n16 | fn get_char(data: String) -> char {\n   |    ^^^^^^^^ ------------\nhelp: consider removing the borrow\n   |\n10 -     get_char(&data);\n10 +     get_char(data);\n   |\n\nerror[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:12:22\n   |\n12 |     string_uppercase(data);\n   |     ---------------- ^^^^\n   |     |                |\n   |     |                expected `&String`, found struct `String`\n   |     |                help: consider borrowing here: `&data`\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:21:4\n   |\n21 | fn string_uppercase(mut data: &String) {\n   |    ^^^^^^^^^^^^^^^^ -----------------\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}
{"wrong_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = &data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:10:14\n   |\n10 |     get_char(&data);\n   |     -------- ^^^^^ expected struct `String`, found `&String`\n   |     |\n   |     arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/move_semantics/move_semantics6.rs:16:4\n   |\n16 | fn get_char(data: String) -> char {\n   |    ^^^^^^^^ ------------\nhelp: consider removing the borrow\n   |\n10 -     get_char(&data);\n10 +     get_char(data);\n   |\n\nerror[E0308]: mismatched types\n  --> exercises/move_semantics/move_semantics6.rs:22:12\n   |\n21 | fn string_uppercase(mut data: String) {\n   |                               ------ expected due to this parameter type\n22 |     data = &data.to_uppercase();\n   |            ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n22 -     data = &data.to_uppercase();\n22 +     data = data.to_uppercase();\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// move_semantics6.rs\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.\n// You can't change anything except adding or removing references.\n\n\n\nfn main() {\n    let mut data = \"Rust is great!\".to_string();\n\n    get_char(&data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &String) -> char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n"}

{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct ColorClassicStruct {\n    // TODO: Something goes here\n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:25:20\n   |\n25 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:26:20\n   |\n26 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:35:20\n   |\n35 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:36:20\n   |\n36 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:44:49\n   |\n14 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n44 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:18:9\n   |\n18 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:\n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected type, found `}`\n  --> exercises/structs/structs1.rs:10:1\n   |\n10 | }\n   | ^ expected type\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:26:20\n   |\n26 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:36:20\n   |\n36 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:45:49\n   |\n15 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n45 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:19:9\n   |\n19 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32\n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:26:20\n   |\n26 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:36:20\n   |\n36 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:45:49\n   |\n15 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n45 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:19:9\n   |\n19 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32,\n   \n}\n\nstruct ColorTupleStruct(/* TODO: Something goes here */);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        // let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.green, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:29:20\n   |\n29 |         assert_eq!(green.blue, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:46:49\n   |\n16 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n46 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:20:9\n   |\n20 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct();\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:46:49\n   |\n16 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n46 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:20:9\n   |\n20 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0412]: cannot find type `u` in this scope\n  --> exercises/structs/structs1.rs:13:29\n   |\n13 | struct ColorTupleStruct(u32,u);\n   |                             ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:27:20\n   |\n27 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:37:20\n   |\n37 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:46:49\n   |\n16 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n46 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:20:9\n   |\n20 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected type, found `}`\n  --> exercises/structs/structs1.rs:12:1\n   |\n12 | }\n   | ^ expected type\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:40:20\n   |\n40 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:47:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n47 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32\n\n};\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected item, found `;`\n  --> exercises/structs/structs1.rs:12:2\n   |\n12 | };\n   |  ^ help: remove this semicolon\n   |\n   = help: braced struct declarations are not followed by a semicolon\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:40:20\n   |\n40 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:47:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n47 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:28:20\n   |\n28 |         assert_eq!(green.red, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:38:20\n   |\n38 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:39:20\n   |\n39 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:40:20\n   |\n40 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:47:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n47 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =struct ColorClassicStruct {\n            red :i32,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected expression, found keyword `struct`\n  --> exercises/structs/structs1.rs:26:21\n   |\n26 |          let green =struct ColorClassicStruct {\n   |                     ^^^^^^ expected expression\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nwarning: unused import: `super::*`\n  --> exercises/structs/structs1.rs:21:9\n   |\n21 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :i32,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:27:18\n   |\n27 |             red :i32,\n   |                  ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:28:19\n   |\n28 |             green:i32,\n   |                   ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected expression, found `,`\n  --> exercises/structs/structs1.rs:27:18\n   |\n26 |          let green =ColorClassicStruct {\n   |                     ------------------ while parsing this struct\n27 |             red :,\n   |                  ^ expected expression\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:28:19\n   |\n28 |             green:i32,\n   |                   ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:i32,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:28:19\n   |\n28 |             green:i32,\n   |                   ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:i32,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0423]: expected value, found builtin type `i32`\n  --> exercises/structs/structs1.rs:29:18\n   |\n29 |             blue:i32,\n   |                  ^^^ not a value\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         }\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs1.rs:31:11\n   |\n31 |          }\n   |           ^ help: add `;` here\n32 |\n33 |         assert_eq!(green.red, 0);\n   |         --------- unexpected token\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        // let green =\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:43:20\n   |\n43 |         assert_eq!(green.0, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:44:20\n   |\n44 |         assert_eq!(green.1, 255);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `green` in this scope\n  --> exercises/structs/structs1.rs:45:20\n   |\n45 |         assert_eq!(green.2, 0);\n   |                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(u32,u32,u32);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:38\n   |\n41 |          let green =ColorTupleStruct(u32,u32,u32);\n   |                                      ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:42\n   |\n41 |          let green =ColorTupleStruct(u32,u32,u32);\n   |                                          ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:46\n   |\n41 |          let green =ColorTupleStruct(u32,u32,u32);\n   |                                              ^^^ not a value\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,u32,u32);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:40\n   |\n41 |          let green =ColorTupleStruct(0,u32,u32);\n   |                                        ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u32`\n  --> exercises/structs/structs1.rs:41:44\n   |\n41 |          let green =ColorTupleStruct(0,u32,u32);\n   |                                            ^^^ not a value\n\nerror[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        // let unit_like_struct =\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error[E0425]: cannot find value `unit_like_struct` in this scope\n  --> exercises/structs/structs1.rs:52:49\n   |\n17 | struct UnitLikeStruct;\n   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here\n...\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}
{"wrong_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n", "error": "error: expected `;`, found keyword `let`\n  --> exercises/structs/structs1.rs:51:46\n   |\n51 |          let unit_like_struct =UnitLikeStruct\n   |                                              ^ help: add `;` here\n52 |         let message = format!(\"{:?}s are fun!\", unit_like_struct);\n   |         --- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// structs1.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.\n\n\n\nstruct ColorClassicStruct {\n   red :i32,\n   green:i32,\n   blue:i32,\n\n}\n\nstruct ColorTupleStruct(u32,u32,u32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n         let green =ColorClassicStruct {\n            red :0,\n            green:255,\n            blue:0,\n         \n         };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n         let green =ColorTupleStruct(0,255,0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n         let unit_like_struct =UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n"}

{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n        // let your_order =\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error[E0609]: no field `name` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:39:31\n   |\n39 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |                               ^^^^\n\nerror[E0609]: no field `year` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:40:31\n   |\n40 |         assert_eq!(your_order.year, order_template.year);\n   |                               ^^^^\n\nerror[E0609]: no field `made_by_phone` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:41:31\n   |\n41 |         assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_mobile` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:42:31\n   |\n42 |         assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n   |                               ^^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_email` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:43:31\n   |\n43 |         assert_eq!(your_order.made_by_email, order_template.made_by_email);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `item_number` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:44:31\n   |\n44 |         assert_eq!(your_order.item_number, order_template.item_number);\n   |                               ^^^^^^^^^^^\n\nerror[E0609]: no field `count` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:45:31\n   |\n45 |         assert_eq!(your_order.count, 1);\n   |                               ^^^^^\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error[E0609]: no field `name` on type `fn() {tests::your_order}`\n  --> exercises/structs/structs2.rs:39:31\n   |\n39 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |                               ^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =\n         {\n            \n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0609]: no field `name` on type `()`\n  --> exercises/structs/structs2.rs:42:31\n   |\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |                               ^^^^\n\nerror[E0609]: no field `year` on type `()`\n  --> exercises/structs/structs2.rs:43:31\n   |\n43 |         assert_eq!(your_order.year, order_template.year);\n   |                               ^^^^\n\nerror[E0609]: no field `made_by_phone` on type `()`\n  --> exercises/structs/structs2.rs:44:31\n   |\n44 |         assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_mobile` on type `()`\n  --> exercises/structs/structs2.rs:45:31\n   |\n45 |         assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n   |                               ^^^^^^^^^^^^^^\n\nerror[E0609]: no field `made_by_email` on type `()`\n  --> exercises/structs/structs2.rs:46:31\n   |\n46 |         assert_eq!(your_order.made_by_email, order_template.made_by_email);\n   |                               ^^^^^^^^^^^^^\n\nerror[E0609]: no field `item_number` on type `()`\n  --> exercises/structs/structs2.rs:47:31\n   |\n47 |         assert_eq!(your_order.item_number, order_template.item_number);\n   |                               ^^^^^^^^^^^\n\nerror[E0609]: no field `count` on type `()`\n  --> exercises/structs/structs2.rs:48:31\n   |\n48 |         assert_eq!(your_order.count, 1);\n   |                               ^^^^^\n\nerror: aborting due to 8 previous errors\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected expression, found `}`\n  --> exercises/structs/structs2.rs:41:10\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n...\n41 |          }\n   |          ^ expected expression\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror[E0425]: cannot find value `name` in this scope\n  --> exercises/structs/structs2.rs:40:13\n   |\n40 |             name\n   |             ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0425.\nFor more information about an error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name=\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `:`, found `=`\n  --> exercises/structs/structs2.rs:40:17\n   |\n40 |             name=\n   |                 ^ help: replace equals symbol with a colon: `:`\n\nerror: expected expression, found `}`\n  --> exercises/structs/structs2.rs:41:10\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n...\n41 |          }\n   |          ^ expected expression\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name=\"Hacker in Rust\".to_string()\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `:`, found `=`\n  --> exercises/structs/structs2.rs:40:17\n   |\n40 |             name=\"Hacker in Rust\".to_string()\n   |                 ^ help: replace equals symbol with a colon: `:`\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:41:11\n   |\n41 |          }\n   |           ^ help: add `;` here\n42 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name=\"Hacker in Rust\".to_string();\n            count:\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `:`, found `=`\n  --> exercises/structs/structs2.rs:40:17\n   |\n40 |             name=\"Hacker in Rust\".to_string();\n   |                 ^ help: replace equals symbol with a colon: `:`\n\nerror: expected one of `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> exercises/structs/structs2.rs:40:46\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n39 |          {\n40 |             name=\"Hacker in Rust\".to_string();\n   |                                              ^ expected one of `,`, `.`, `?`, `}`, or an operator\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string();\n            count:1\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> exercises/structs/structs2.rs:40:46\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n39 |          {\n40 |             name:\"Hacker in Rust\".to_string();\n   |                                              ^\n   |                                              |\n   |                                              expected one of `,`, `.`, `?`, `}`, or an operator\n   |                                              help: try adding a comma: `,`\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string()\n            count:1\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `count`\n  --> exercises/structs/structs2.rs:41:13\n   |\n38 |          let your_order =order\n   |                          ----- while parsing this struct\n39 |          {\n40 |             name:\"Hacker in Rust\".to_string()\n   |                                              -\n   |                                              |\n   |                                              expected one of `,`, `.`, `?`, `}`, or an operator\n   |                                              help: try adding a comma: `,`\n41 |             count:1\n   |             ^^^^^ unexpected token\n\nerror: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:42:11\n   |\n42 |          }\n   |           ^ help: add `;` here\n43 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            \n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:43:11\n   |\n43 |          }\n   |           ^ help: add `;` here\n44 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror[E0422]: cannot find struct, variant or union type `order` in this scope\n  --> exercises/structs/structs2.rs:38:26\n   |\n8  | struct Order {\n   | ------------ similarly named struct `Order` defined here\n...\n38 |          let your_order =order\n   |                          ^^^^^ help: a struct with a similar name exists (notice the capitalization): `Order`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0422`.\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}
{"wrong_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         }\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n", "error": "error: expected `;`, found `assert_eq`\n  --> exercises/structs/structs2.rs:43:11\n   |\n43 |          }\n   |           ^ help: add `;` here\n44 |         assert_eq!(your_order.name, \"Hacker in Rust\");\n   |         --------- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// structs2.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n         let your_order =Order\n         {\n            name:\"Hacker in Rust\".to_string(),\n            count:1,\n            ..order_template\n         };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n"}

{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> ??? {\n        // Something goes here...\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> ??? {\n        // Something goes here...\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/structs/structs3.rs:29:36\n   |\n16 | impl Package {\n   |              - while parsing this item list starting here\n...\n29 |     fn is_international(&self) -> ??? {\n   |                                    ^ expected identifier\n...\n36 | }\n   | - the item list ends here\n\nerror[E0599]: no method named `is_international` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:58:25\n   |\n10 | struct Package {\n   | -------------- method `is_international` not found for this struct\n...\n58 |         assert!(package.is_international());\n   |                         ^^^^^^^^^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `is_international` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:68:26\n   |\n10 | struct Package {\n   | -------------- method `is_international` not found for this struct\n...\n68 |         assert!(!package.is_international());\n   |                          ^^^^^^^^^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:80:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n80 |         assert_eq!(package.get_fees(cents_per_gram), 4500);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:81:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n81 |         assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        // Something goes here...\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> ??? {\n        // Something goes here...\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/structs/structs3.rs:33:49\n   |\n16 | impl Package {\n   |              - while parsing this item list starting here\n...\n33 |     fn get_fees(&self, cents_per_gram: i32) -> ??? {\n   |                                                 ^ expected identifier\n...\n36 | }\n   | - the item list ends here\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:80:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n80 |         assert_eq!(package.get_fees(cents_per_gram), 4500);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror[E0599]: no method named `get_fees` found for struct `Package` in the current scope\n  --> exercises/structs/structs3.rs:81:28\n   |\n10 | struct Package {\n   | -------------- method `get_fees` not found for this struct\n...\n81 |         assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n   |                            ^^^^^^^^ method not found in `Package`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        \n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        // Something goes here...\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:33:48\n   |\n33 |     fn get_fees(&self, cents_per_gram: i32) -> i32{\n   |        --------                                ^^^ expected `i32`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n   |\nhelp: consider returning the local binding `cents_per_gram`\n   |\n33 ~     fn get_fees(&self, cents_per_gram: i32) -> i32{\n34 +         cents_per_gram\n35 ~     // Something goes here...\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        \n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        \n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:29:35\n   |\n29 |     fn is_international(&self) -> bool {\n   |        ----------------           ^^^^ expected `bool`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/structs/structs3.rs:31:5\n   |\n31 |     }\n   |     ^\n\nerror[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:30:9\n   |\n29 |     fn is_international(&self) -> bool {\n   |                                   ---- expected `bool` because of return type\n30 |         self.\n   |         ^^^^ expected `bool`, found `&Package`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror[E0308]: mismatched types\n  --> exercises/structs/structs3.rs:30:9\n   |\n29 |     fn is_international(&self) -> bool {\n   |                                   ---- expected `bool` because of return type\n30 |         self.sender_country\n   |         ^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error: expected expression, found `}`\n  --> exercises/structs/structs3.rs:31:5\n   |\n31 |     }\n   |     ^ expected expression\n\nerror[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `recipient_country` in this scope\n  --> exercises/structs/structs3.rs:30:30\n   |\n30 |         self.sender_country!=recipient_country\n   |                              ^^^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.recipient_country`\n\nerror[E0425]: cannot find value `weight_in_grams` in this scope\n  --> exercises/structs/structs3.rs:34:9\n   |\n34 |         weight_in_grams*3\n   |         ^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.weight_in_grams`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `recipient_country` in this scope\n  --> exercises/structs/structs3.rs:30:30\n   |\n30 |         self.sender_country!=recipient_country\n   |                              ^^^^^^^^^^^^^^^^^ help: you might have meant to use the available field: `self.recipient_country`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=srecipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.weight_in_grams*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0425]: cannot find value `srecipient_country` in this scope\n  --> exercises/structs/structs3.rs:30:30\n   |\n30 |         self.sender_country!=srecipient_country\n   |                              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.wcents_per_gram*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0609]: no field `wcents_per_gram` on type `&Package`\n  --> exercises/structs/structs3.rs:34:14\n   |\n34 |         self.wcents_per_gram*3\n   |              ^^^^^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `sender_country`, `recipient_country`, `weight_in_grams`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}
{"wrong_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        self.cents_per_gram*3\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n", "error": "error[E0609]: no field `cents_per_gram` on type `&Package`\n  --> exercises/structs/structs3.rs:34:14\n   |\n34 |         self.cents_per_gram*3\n   |              ^^^^^^^^^^^^^^ unknown field\n   |\n   = note: available fields are: `sender_country`, `recipient_country`, `weight_in_grams`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// structs3.rs\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.\n\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: i32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {\n        if weight_in_grams <= 0 {\n            panic!(\"Can not ship a weightless package.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&self) -> bool {\n        self.sender_country!=self.recipient_country\n    }\n\n    fn get_fees(&self, cents_per_gram: i32) -> i32{\n        cents_per_gram*1500\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, -2210);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n"}

{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define a few types of messages as used below\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:12:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n12 |     println!(\"{:?}\", Message::Quit);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:13:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n13 |     println!(\"{:?}\", Message::Echo);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:14:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Move` not found for this enum\n...\n14 |     println!(\"{:?}\", Message::Move);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:15:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n15 |     println!(\"{:?}\", Message::ChangeColor);\n   |                               ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}
{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error: expected item, found `;`\n --> exercises/enums/enums1.rs:8:10\n  |\n8 |     Quit);\n  |          ^ help: remove this semicolon\n  |\n  = help: enum declarations are not followed by a semicolon\n\nerror: macros that expand to items must be delimited with braces or followed by a semicolon\n  --> exercises/enums/enums1.rs:11:13\n   |\n11 |       println!(\"{:?}\", Message::ChangeColor\n   |  _____________^\n12 | | }\n   | |_^\n   |\nhelp: change the delimiters to curly braces\n   |\n11 |     println! { /* items */ }\n   |              ~~~~~~~~~~~~~~~\nhelp: add a semicolon\n   |\n12 | };\n   |  +\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums1.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     Quit);\n  |         ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums1.rs:11:13\n   |\n11 |     println!(\"{:?}\", Message::ChangeColor\n   |             ^ unclosed delimiter\n12 | }\n   | ^ mismatched closing delimiter\n\nerror: macro expansion ignores token `{` and any following\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:135:23\n    |\n135 |       ($($arg:tt)*) => {{\n    |  _______________________^\n136 | |         $crate::io::_print($crate::format_args_nl!($($arg)*));\n137 | |     }};\n    | |_____^\n    |\n   ::: exercises/enums/enums1.rs:9:5\n    |\n9   |       println!(\"{:?}\", Message::Echo);\n    |       ------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `println!` is likely invalid in item context\n\nerror: macro expansion ignores token `{` and any following\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:135:23\n    |\n135 |       ($($arg:tt)*) => {{\n    |  _______________________^\n136 | |         $crate::io::_print($crate::format_args_nl!($($arg)*));\n137 | |     }};\n    | |_____^\n    |\n   ::: exercises/enums/enums1.rs:10:5\n    |\n10  |       println!(\"{:?}\", Message::Move);\n    |       ------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `println!` is likely invalid in item context\n\nerror: macro expansion ignores token `{` and any following\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:135:23\n    |\n135 |       ($($arg:tt)*) => {{\n    |  _______________________^\n136 | |         $crate::io::_print($crate::format_args_nl!($($arg)*));\n137 | |     }};\n    | |_____^\n    |\n   ::: exercises/enums/enums1.rs:11:5\n    |\n11  | /     println!(\"{:?}\", Message::ChangeColor\n12  | | }\n    | |_- caused by the macro expansion here\n    |\n    = note: the usage of `println!` is likely invalid in item context\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:16:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n16 |     println!(\"{:?}\", Message::Echo);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:17:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Move` not found for this enum\n...\n17 |     println!(\"{:?}\", Message::Move);\n   |                               ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums1.rs:18:31\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n18 |     println!(\"{:?}\", Message::ChangeColor);\n   |                               ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 10 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}
{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    Quit);\n    Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error: unexpected closing delimiter: `)`\n --> exercises/enums/enums1.rs:9:9\n  |\n9 |     Echo);\n  |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums1.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     Quit);\n  |         ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}
{"wrong_code": "// enums1.rs\n// No hints this time! ;)\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    Quit\n    Echo\n    Move\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n", "error": "error: expected one of `(`, `,`, `=`, `{`, or `}`, found `Echo`\n --> exercises/enums/enums1.rs:9:5\n  |\n8 |     Quit\n  |         -\n  |         |\n  |         expected one of `(`, `,`, `=`, `{`, or `}`\n  |         help: missing `,`\n9 |     Echo\n  |     ^^^^ unexpected token\n\nerror: expected one of `(`, `,`, `=`, `{`, or `}`, found `Move`\n  --> exercises/enums/enums1.rs:10:5\n   |\n9  |     Echo\n   |         -\n   |         |\n   |         expected one of `(`, `,`, `=`, `{`, or `}`\n   |         help: missing `,`\n10 |     Move\n   |     ^^^^ unexpected token\n\nerror: expected one of `(`, `,`, `=`, `{`, or `}`, found `ChangeColor`\n  --> exercises/enums/enums1.rs:11:5\n   |\n10 |     Move\n   |         -\n   |         |\n   |         expected one of `(`, `,`, `=`, `{`, or `}`\n   |         help: missing `,`\n11 |     ChangeColor\n   |     ^^^^^^^^^^^ unexpected token\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums1.rs\n// No hints this time! ;)\n\n\n\n#[derive(Debug)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n"}

{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define the different variants used below\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error[E0599]: no variant named `Move` found for enum `Message`\n  --> exercises/enums/enums2.rs:19:18\n   |\n7  | enum Message {\n   | ------------ variant `Move` not found here\n...\n19 |         Message::Move { x: 10, y: 30 },\n   |                  ^^^^ variant not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:20:18\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n20 |         Message::Echo(String::from(\"hello world\")),\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:21:18\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n21 |         Message::ChangeColor(200, 255, 255),\n   |                  ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:22:18\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n22 |         Message::Quit,\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define the different variants used below\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error[E0599]: no variant named `Move` found for enum `Message`\n  --> exercises/enums/enums2.rs:18:18\n   |\n6  | enum Message {\n   | ------------ variant `Move` not found here\n...\n18 |         Message::Move { x: 10, y: 30 },\n   |                  ^^^^ variant not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:19:18\n   |\n6  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n19 |         Message::Echo(String::from(\"hello world\")),\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:20:18\n   |\n6  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n20 |         Message::ChangeColor(200, 255, 255),\n   |                  ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums2.rs:21:18\n   |\n6  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n21 |         Message::Quit,\n   |                  ^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: 10, y: 30 },\nEcho(String::from(\"hello world\")),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `10`\n --> exercises/enums/enums2.rs:7:15\n  |\n7 |     Move { x: 10, y: 30 },\n  |               ^^ expected type\n\nerror: expected type, found `\"hello world\"`\n --> exercises/enums/enums2.rs:8:19\n  |\n8 | Echo(String::from(\"hello world\")),\n  |                   ^^^^^^^^^^^^^ expected type\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: 30 },\nEcho(String::from(\"hello world\")),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `30`\n --> exercises/enums/enums2.rs:7:23\n  |\n7 |     Move { x: i32, y: 30 },\n  |                       ^^ expected type\n\nerror: expected type, found `\"hello world\"`\n --> exercises/enums/enums2.rs:8:19\n  |\n8 | Echo(String::from(\"hello world\")),\n  |                   ^^^^^^^^^^^^^ expected type\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String::from(\"hello world\")),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `\"hello world\"`\n --> exercises/enums/enums2.rs:8:19\n  |\n8 | Echo(String::from(\"hello world\")),\n  |                   ^^^^^^^^^^^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(200, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `200`\n --> exercises/enums/enums2.rs:9:13\n  |\n9 | ChangeColor(200, 255, 255),\n  |             ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, 255, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums2.rs:9:18\n  |\n9 | ChangeColor(u32, 255, 255),\n  |                  ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}
{"wrong_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, 255),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums2.rs:9:23\n  |\n9 | ChangeColor(u32, u32, 255),\n  |                       ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums2.rs\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(Debug)]\nenum Message {\n    Move { x: i32, y: i32 },\nEcho(String),\nChangeColor(u32, u32, u32),\nQuit,\n}\n\nimpl Message {\n    fn call(&self) {\n        println!(\"{:?}\", &self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n}\n"}

{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nenum Message {\n    // TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:55:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `ChangeColor` not found for this enum\n...\n55 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                ^^^^^^^^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:56:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Echo` not found for this enum\n...\n56 |         state.process(Message::Echo(String::from(\"hello world\")));\n   |                                ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:57:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Move` not found for this enum\n...\n57 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                                ^^^^ variant or associated item not found in `Message`\n\nerror[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope\n  --> exercises/enums/enums3.rs:58:32\n   |\n7  | enum Message {\n   | ------------ variant or associated item `Quit` not found for this enum\n...\n58 |         state.process(Message::Quit);\n   |                                ^^^^ variant or associated item not found in `Message`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String::from(\"hello world\"\nMove(Point { x: 10, y: 15 }));\nQuit);// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:13:1\n   |\n11 | Move(Point { x: 10, y: 15 }));\n   |            -              - ...matches this closing brace\n   |            |\n   |            this opening brace...\n12 | Quit);// TODO: implement the message variant types based on their usage below\n13 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor((255, 0, 255)));\n  |                               ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String::from(\"hello world\"\nMove(Point { x: 10, y: 15 }));\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums3.rs:9:18\n  |\n9 |     ChangeColor((255, 0, 255)));\n  |                  ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String::from(\"hello world\"\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: this file contains an unclosed delimiter\n  --> exercises/enums/enums3.rs:70:3\n   |\n10 | Echo(String::from(\"hello world\"\n   |     - unclosed delimiter\n...\n70 | }\n   |   ^\n\nerror: expected type, found `255`\n --> exercises/enums/enums3.rs:9:18\n  |\n9 |     ChangeColor((255, 0, 255)));\n  |                  ^^^ expected type\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor((255, 0, 255)));\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:14:1\n   |\n14 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor((255, 0, 255)));\n  |                               ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32, , 255)));\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `)`\n --> exercises/enums/enums3.rs:9:29\n  |\n9 |     ChangeColor(u32, , 255)));\n  |                             ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor(u32, , 255)));\n  |                            ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, 255)));\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `)`\n --> exercises/enums/enums3.rs:9:31\n  |\n9 |     ChangeColor(u32,u32, 255)));\n  |                               ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 |     ChangeColor(u32,u32, 255)));\n  |                              ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, 255);\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `255`\n --> exercises/enums/enums3.rs:9:26\n  |\n9 |     ChangeColor(u32,u32, 255);\n  |                          ^^^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32,;\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `;`\n --> exercises/enums/enums3.rs:9:30\n  |\n9 |     ChangeColor(u32,u32, u32,;\n  |                              ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:60:23\n   |\n60 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:60:44\n   |\n60 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n60 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:62:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n62 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        \n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:61:23\n   |\n61 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:61:44\n   |\n61 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n61 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:63:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n63 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)));\nMessage::Echo(String::from(\"hello world\")));\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:50:9\n   |\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                     -              - ...matches this closing brace\n   |                     |\n   |                     this opening brace...\n50 |         } {\n   |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)));\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:44:45\n   |\n44 |     fn process(&mut self, message: Message) {\n   |                                             ^ unclosed delimiter\n...\n48 | Message::Echo(String::from(\"hello world\")));\n   |                                           ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:27:12\n   |\n27 | impl State {\n   |            ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)))=?;\nMessage::Echo(String::from(\"hello world\")));\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:50:9\n   |\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                     -              - ...matches this closing brace\n   |                     |\n   |                     this opening brace...\n50 |         } {\n   |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)))=?;\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:44:45\n   |\n44 |     fn process(&mut self, message: Message) {\n   |                                             ^ unclosed delimiter\n...\n48 | Message::Echo(String::from(\"hello world\")));\n   |                                           ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:27:12\n   |\n27 | impl State {\n   |            ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)))=>;\nMessage::Echo(String::from(\"hello world\")));\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:50:9\n   |\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                     -              - ...matches this closing brace\n   |                     |\n   |                     this opening brace...\n50 |         } {\n   |         ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)))=>;\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:44:45\n   |\n44 |     fn process(&mut self, message: Message) {\n   |                                             ^ unclosed delimiter\n...\n48 | Message::Echo(String::from(\"hello world\")));\n   |                                           ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:27:12\n   |\n27 | impl State {\n   |            ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor((255, 0, 255)))=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:54:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n53 |     }\n   |     - ...matches this closing brace\n54 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor((255, 0, 255)))=>;\n   |                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor())=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:54:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n53 |     }\n   |     - ...matches this closing brace\n54 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n47 |             Message::ChangeColor())=>;\n   |                                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor()=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:35\n   |\n47 |             Message::ChangeColor()=>;\n   |                                   ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor()=>;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>;\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.;\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(color);\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(color);\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.change_color(color);\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color;\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color;\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.change_color;\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c);\nMessage::Echo(String::from(\"hello world\";\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c);\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/enums/enums3.rs:48:14\n   |\n46 |         match {\n   |               - closing delimiter possibly meant for this\n47 |             Message::ChangeColor(C)=>self.change_color(c);\n48 | Message::Echo(String::from(\"hello world\";\n   |              ^ unclosed delimiter\n49 | Message::Move(Point { x: 10, y: 15 }));\n50 |         } {\n   |         ^ mismatched closing delimiter\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c);\nMessage::Echo(s);\nMessage::Move(Point { x: 10, y: 15 }));\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:54:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n53 |     }\n   |     - ...matches this closing brace\n54 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> exercises/enums/enums3.rs:46:15\n   |\n46 |         match {\n   |               ^ unclosed delimiter\n...\n49 | Message::Move(Point { x: 10, y: 15 }));\n   |                                      ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c);\nMessage::Echo(s)=>self.echo(s);\nMessage::Move();\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c);\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\nMessage::Echo(s)=>self.echo(s),\nMessage::Move(p)=>self.move_position(p);\n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:67:23\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:67:44\n   |\n67 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n67 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:69:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n69 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            \n        } {\n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:55:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n54 |     }\n   |     - ...matches this closing brace\n55 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n  --> exercises/enums/enums3.rs:47:36\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                    ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `?`, `{`, or an operator, found `}`\n  --> exercises/enums/enums3.rs:53:9\n   |\n46 |         match {\n   |         ----- while parsing this `match` expression\n...\n51 |         } \n   |          - expected one of `.`, `?`, `{`, or an operator\n52 |             \n53 |         }\n   |         ^ unexpected token\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0618.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match {\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n}=\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:55:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n54 |     }\n   |     - ...matches this closing brace\n55 | }=\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n}}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:55:1\n   |\n27 | impl State {\n   |            - this opening brace...\n...\n54 |     }\n   |     - ...matches this closing brace\n55 | }}\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0425]: cannot find value `c` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `C`\n\nerror[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |                 --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(c),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(c),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0425, E0532, E0618.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |                 --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:5\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |     ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0532, E0618.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \n    ChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    \n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: this file contains an unclosed delimiter\n  --> exercises/enums/enums3.rs:78:3\n   |\n27 | impl State {\n   |            - unclosed delimiter\n...\n44 |     fn process(&mut self, message: Message) {\n   |                                             - this delimiter might not be properly closed...\n...\n53 |         }\n   |         - ...as it matches this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror: module is not supported in `trait`s or `impl`s\n  --> exercises/enums/enums3.rs:58:1\n   |\n58 | mod tests {\n   | ^^^^^^^^^\n   |\n   = help: consider moving the module out to a nearby module scope\n\nerror[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  |     ChangeColor(u32,u32, u32),\n   |                 --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0532.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove,\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0532]: expected tuple struct or tuple variant, found unit variant `Message::Move`\n  --> exercises/enums/enums3.rs:49:13\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |             ^^^^^^^^^^^^^^^^ help: use this syntax instead: `Message::Move`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0618]: expected function, found `Message`\n  --> exercises/enums/enums3.rs:70:23\n   |\n11 | Move,\n   | ---- `Message::Move` defined here\n...\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^------------------------\n   |                       |\n   |                       call expression requires function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0532, E0618.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 0 fields\n  --> exercises/enums/enums3.rs:49:27\n   |\n11 | Move(),\n   | ---- tuple variant has 0 fields\n...\n49 |             Message::Move(p)=>self.move_position(p),\n   |                           ^ expected 0 fields, found 1\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this enum variant takes 0 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:70:23\n   |\n70 |         state.process(Message::Move(Point { x: 10, y: 15 }));\n   |                       ^^^^^^^^^^^^^ ---------------------- argument of type `Point` unexpected\n   |\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:11:1\n   |\n11 | Move(),\n   | ^^^^\nhelp: remove the extra argument\n   |\n70 |         state.process(Message::Move());\n   |                                    ~~\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `point` in this scope\n  --> exercises/enums/enums3.rs:11:6\n   |\n11 | Move(point),\n   |      ^^^^^ help: a struct with a similar name exists: `Point`\n...\n16 | struct Point {\n   | ------------ similarly named struct `Point` defined here\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0412.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point{x}),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n  --> exercises/enums/enums3.rs:11:11\n   |\n11 | Move(point{x}),\n   |           ^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point{x:i32}),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n  --> exercises/enums/enums3.rs:11:11\n   |\n11 | Move(point{x:i32}),\n   |           ^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(point{x:i32,y:i32}),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n  --> exercises/enums/enums3.rs:11:11\n   |\n11 | Move(point{x:i32,y:i32}),\n   |           ^ expected one of 7 possible tokens\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(C)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(C, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(C, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0023, E0061.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0425]: cannot find value `C` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(c)=>self.change_color(C),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `c`\n\nerror[E0023]: this pattern has 1 field, but the corresponding tuple variant has 3 fields\n  --> exercises/enums/enums3.rs:47:34\n   |\n9  | ChangeColor(u32,u32, u32),\n   |             --- ---  --- tuple variant has 3 fields\n...\n47 |             Message::ChangeColor(c)=>self.change_color(C),\n   |                                  ^ expected 3 fields, found 1\n   |\nhelp: use `_` to explicitly ignore each field\n   |\n47 |             Message::ChangeColor(c, _, _)=>self.change_color(C),\n   |                                   ++++++\nhelp: use `..` to ignore the rest of the fields\n   |\n47 |             Message::ChangeColor(c, ..)=>self.change_color(C),\n   |                                   ++++\n\nerror[E0061]: this enum variant takes 3 arguments but 1 argument was supplied\n  --> exercises/enums/enums3.rs:68:23\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                       ^^^^^^^^^^^^^^^^^^^^--------------- two arguments of type `u32` and `u32` are missing\n   |\nnote: expected `u32`, found tuple\n  --> exercises/enums/enums3.rs:68:44\n   |\n68 |         state.process(Message::ChangeColor((255, 0, 255)));\n   |                                            ^^^^^^^^^^^^^\n   = note: expected type `u32`\n             found tuple `({integer}, {integer}, {integer})`\nnote: tuple variant defined here\n  --> exercises/enums/enums3.rs:9:1\n   |\n9  | ChangeColor(u32,u32, u32),\n   | ^^^^^^^^^^^\nhelp: provide the arguments\n   |\n68 |         state.process(Message::ChangeColor(/* u32 */, /* u32 */, /* u32 */));\n   |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0023, E0061, E0425.\nFor more information about an error, try `rustc --explain E0023`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c:c)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> exercises/enums/enums3.rs:47:35\n   |\n47 |             Message::ChangeColor(c:c)=>self.change_color(C),\n   |                                   ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(u32,u32, u32),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c:co)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> exercises/enums/enums3.rs:47:35\n   |\n47 |             Message::ChangeColor(c:co)=>self.change_color(C),\n   |                                   ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(c),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `c` in this scope\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor(c),\n  |             ^ not found in this scope\n\nerror[E0425]: cannot find value `C` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(c)=>self.change_color(C),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `c`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(c),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(c)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `c` in this scope\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor(c),\n  |             ^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0412`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor(c),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(c),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0412]: cannot find type `c` in this scope\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor(c),\n  |             ^ not found in this scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> exercises/enums/enums3.rs:47:56\n   |\n47 |             Message::ChangeColor(C)=>self.change_color(c),\n   |                                                        ^ help: a local variable with a similar name exists (notice the capitalization): `C`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}

{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `{`\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor({(u8, u8, u8)),\n  |             ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)}),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `{`\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor({(u8, u8, u8)}),\n  |             ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor({(u8, u8, u8)]),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: expected type, found `{`\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor({(u8, u8, u8)]),\n  |             ^ expected type\n\nerror: aborting due to previous error\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor([(u8, u8, u8)]),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error[E0277]: the size for values of type `[(u8, u8, u8)]` cannot be known at compilation time\n --> exercises/enums/enums3.rs:9:13\n  |\n9 | ChangeColor([(u8, u8, u8)]),\n  |             ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `[(u8, u8, u8)]`\n  = note: no field of an enum variant may have a dynamically sized type\n  = help: change the field's type to have a statically known size\nhelp: borrowed types always have a statically known size\n  |\n9 | ChangeColor(&[(u8, u8, u8)]),\n  |             +\nhelp: the `Box` type always has a statically known size and allocates its contents in the heap\n  |\n9 | ChangeColor(Box<[(u8, u8, u8)]>),\n  |             ++++              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}
{"wrong_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)]),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n", "error": "error: unexpected closing delimiter: `}`\n  --> exercises/enums/enums3.rs:14:1\n   |\n14 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `]`\n --> exercises/enums/enums3.rs:9:12\n  |\n9 | ChangeColor((u8, u8, u8)]),\n  |            ^            ^ mismatched closing delimiter\n  |            |\n  |            unclosed delimiter\n\nerror: mismatched closing delimiter: `)`\n --> exercises/enums/enums3.rs:7:14\n  |\n7 | enum Message {\n  |              ^ unclosed delimiter\n8 |     \n9 | ChangeColor((u8, u8, u8)]),\n  |                          ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// enums3.rs\n// Address all the TODOs to make the tests pass!\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.\n\n\n\nenum Message {\n    \nChangeColor((u8, u8, u8)),\nEcho(String),\nMove(Point),\nQuit\n// TODO: implement the message variant types based on their usage below\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\nimpl State {\n    fn change_color(&mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&self, s: String) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(&mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        match message{\n            Message::ChangeColor(C)=>self.change_color(C),\n            Message::Echo(s)=>self.echo(s),\n            Message::Move(p)=>self.move_position(p),\n            Message::Quit=>self.quit(),\n        } \n            \n        }\n    }\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n        };\n        state.process(Message::ChangeColor((255, 0, 255)));\n        state.process(Message::Echo(String::from(\"hello world\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n    }\n}\n"}

{"wrong_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\"\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/strings/strings1.rs:13:5\n   |\n12 | fn current_favorite_color() -> String {\n   |                                ------ expected `String` because of return type\n13 |     \"blue\"\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_string()\n}\n"}
{"wrong_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to\n}\n", "error": "error[E0609]: no field `to` on type `&'static str`\n  --> exercises/strings/strings1.rs:13:12\n   |\n13 |     \"blue\".to\n   |            ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_string()\n}\n"}
{"wrong_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_\n}\n", "error": "error[E0609]: no field `to_` on type `&'static str`\n  --> exercises/strings/strings1.rs:13:12\n   |\n13 |     \"blue\".to_\n   |            ^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings1.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -> String {\n    \"blue\".to_string()\n}\n"}

{"wrong_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    let z = &mut x;\n    *y += 100;\n    \n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n", "error": "error[E0499]: cannot borrow `x` as mutable more than once at a time\n  --> exercises/move_semantics/move_semantics5.rs:11:13\n   |\n10 |     let y = &mut x;\n   |             ------ first mutable borrow occurs here\n11 |     let z = &mut x;\n   |             ^^^^^^ second mutable borrow occurs here\n12 |     *y += 100;\n   |     --------- first borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n", "right_code": "// move_semantics5.rs\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let  mut x = 100;\n    let y = &mut x;\n    *y += 100;\n    let z = &mut x;\n   \n    \n    *z += 1000;\n    assert_eq!(x, 1200);\n}\n"}

{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn trim_me(input: &str) -> String {\n    // TODO: Remove whitespace from both ends of a string!\n    ???\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n --> exercises/strings/strings3.rs:8:5\n  |\n8 |     ???\n  |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:13:5\n   |\n13 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:18:5\n   |\n18 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    in\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found keyword `in`\n --> exercises/strings/strings3.rs:7:5\n  |\n7 |     in\n  |     ^^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `trim` on type `&str`\n --> exercises/strings/strings3.rs:7:11\n  |\n7 |     input.trim\n  |           ^^^^ method, not a field\n  |\nhelp: use parentheses to call the method\n  |\n7 |     input.trim()\n  |               ++\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0609]: no field `to` on type `&str`\n --> exercises/strings/strings3.rs:7:18\n  |\n7 |     input.trim().to\n  |                  ^^\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string(())\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n    --> exercises/strings/strings3.rs:7:18\n     |\n7    |     input.trim().to_string(())\n     |                  ^^^^^^^^^ -- argument of type `()` unexpected\n     |\nnote: associated function defined here\n    --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2489:8\n     |\n2489 |     fn to_string(&self) -> String;\n     |        ^^^^^^^^^\nhelp: remove the extra argument\n     |\n7    |     input.trim().to_string()\n     |                           ~~\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    ???\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     ???\n   |     ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    in\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found keyword `in`\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |     in\n   |     ^^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    input.to_string+\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `}`\n  --> exercises/strings/strings3.rs:13:1\n   |\n13 | }\n   | ^ expected expression\n\nerror: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    input.to_string+\" world!\"\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:11\n   |\n12 |     input.to_string+\" world!\"\n   |           ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     input.to_string()+\" world!\"\n   |                    ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\"\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> exercises/strings/strings3.rs:12:5\n   |\n10 | fn compose_me(input: &str) -> String {\n   |                                      - closing delimiter possibly meant for this\n11 |     // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n12 |     (input.to_string+\" world!\"\n   |     ^ unclosed delimiter\n13 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around block return value\n  --> exercises/strings/strings3.rs:12:5\n   |\n12 |       (input.to_string+\" world!\"\n   |  _____^_________________________^\n13 | | }\n   | |_^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     (input.to_string+\" world!\"\n12 +     input.to_string+\" world!\"\n   |\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\"\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\"\n   |                     ++\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\").to_string\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\").to_string\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\").to_string\n   |                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ???\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ???\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\").to_string()\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\").to_string()\n   |                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ?\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ?\n   |     ^ expected expression\n\nerror[E0615]: attempted to take value of method `to_string` on type `&str`\n  --> exercises/strings/strings3.rs:12:12\n   |\n12 |     (input.to_string+\" world!\").to_string()\n   |            ^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     (input.to_string()+\" world!\").to_string()\n   |                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0615`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    ?\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     ?\n   |     ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    re\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find value `re` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     re\n   |     ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    replace\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find value `replace` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     replace\n   |     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n6  | use std::mem::replace;\n   |\n6  | use std::ptr::replace;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    replace()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find function `replace` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     replace()\n   |     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n   |\n6  | use std::mem::replace;\n   |\n6  | use std::ptr::replace;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    inreplace()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0425]: cannot find function `inreplace` in this scope\n  --> exercises/strings/strings3.rs:17:5\n   |\n17 |     inreplace()\n   |     ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0061]: this function takes 2 arguments but 0 arguments were supplied\n   --> exercises/strings/strings3.rs:17:11\n    |\n17  |     input.replace()\n    |           ^^^^^^^-- two arguments are missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:271:12\n    |\n271 |     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n    |            ^^^^^^^\nhelp: provide the arguments\n    |\n17  |     input.replace(/* value */, /* &str */)\n    |                  ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> exercises/strings/strings3.rs:17:11\n    |\n17  |     input.replace(\"cars\")\n    |           ^^^^^^^-------- an argument of type `&str` is missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:271:12\n    |\n271 |     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n    |            ^^^^^^^\nhelp: provide the argument\n    |\n17  |     input.replace(\"cars\", /* &str */)\n    |                  ~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"ballons\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/strings/strings3.rs:15:31\n   |\n15 | fn replace_me(input: &str) -> String {\n   |    ----------                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n16 |     // TODO: Replace \"cars\" in the string with \"balloons\"!\n17 |     input.replace(\"cars\",\"ballons\");\n   |                                    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"ballons\").\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/strings/strings3.rs:18:1\n   |\n18 | }\n   | ^\n\nerror: aborting due to previous error\n\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(ballons\").\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0765]: unterminated double quote string\n  --> exercises/strings/strings3.rs:40:85\n   |\n40 |           assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n   |  _____________________________________________________________________________________^\n41 | |     }\n42 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0765`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"ballons\").\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/strings/strings3.rs:18:1\n   |\n18 | }\n   | ^\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> exercises/strings/strings3.rs:17:11\n    |\n17  |     input.replace(\"ballons\").\n    |           ^^^^^^^----------- an argument of type `&str` is missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:271:12\n    |\n271 |     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n    |            ^^^^^^^\nhelp: provide the argument\n    |\n17  |     input.replace(\"ballons\", /* &str */).\n    |                  ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}
{"wrong_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"ballons\").t\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n", "error": "error[E0609]: no field `t` on type `String`\n  --> exercises/strings/strings3.rs:17:37\n   |\n17 |     input.replace(\"cars\",\"ballons\").t\n   |                                     ^ unknown field\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// strings3.rs\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.\n\n\n\nfn trim_me(input: &str) -> String {\n    input.trim().to_string()\n}\n\nfn compose_me(input: &str) -> String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    (input.to_string()+\" world!\").to_string()\n}\n\nfn replace_me(input: &str) -> String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\",\"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n"}

{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    ???(\"blue\");\n    ???(\"red\".to_string());\n    ???(String::from(\"hi\"));\n    ???(\"rust is fun!\".to_owned());\n    ???(\"nice weather\".into());\n    ???(format!(\"Interpolation {}\", \"Station\"));\n    ???(&String::from(\"abc\")[0..1]);\n    ???(\"  hello there \".trim());\n    ???(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    ???(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     ???(\"blue\");\n   |     ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    (\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0282]: type annotations needed\n  --> exercises/strings/strings4.rs:23:21\n   |\n23 |     (\"nice weather\".into());\n   |                     ^^^^\n   |\nhelp: try using a fully qualified path to specify the expected types\n   |\n23 |     (<&str as Into<T>>::into(\"nice weather\"));\n   |      ++++++++++++++++++++++++              ~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    S(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function, tuple struct or tuple variant `S` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     S(\"blue\");\n   |     ^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    St(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function, tuple struct or tuple variant `St` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     St(\"blue\");\n   |     ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn string_slice(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    string_slice(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function `st` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     st(\"blue\");\n   |     ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    string_slice(\"blue\");\n    (\"red\".to_string());\n    (String::from(\"hi\"));\n    (\"rust is fun!\".to_owned());\n    (\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error[E0425]: cannot find function `string_slice` in this scope\n  --> exercises/strings/strings4.rs:19:5\n   |\n19 |     string_slice(\"blue\");\n   |     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}
{"wrong_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n// I AM NOT DONE\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    (st\"nice weather\".into());\n    (format!(\"Interpolation {}\", \"Station\"));\n    (&String::from(\"abc\")[0..1]);\n    (\"  hello there \".trim());\n    (\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    (\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n", "error": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `\"nice weather\"`\n  --> exercises/strings/strings4.rs:23:8\n   |\n23 |     (st\"nice weather\".into());\n   |        -^^^^^^^^^^^^^\n   |        |\n   |        expected one of 8 possible tokens\n   |        help: missing `,`\n\nerror[E0283]: type annotations needed\n  --> exercises/strings/strings4.rs:23:23\n   |\n23 |     (st\"nice weather\".into());\n   |                       ^^^^\n   |\n   = note: cannot satisfy `_: From<&str>`\n   = note: required for `&str` to implement `Into<_>`\nhelp: try using a fully qualified path to specify the expected types\n   |\n23 |     (st<&str as Into<T>>::into(\"nice weather\"));\n   |        ++++++++++++++++++++++++              ~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0283`.\n", "right_code": "// strings4.rs\n\n// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n// No hints this time!\n\n\n\nfn sl(arg: &str) {\n    println!(\"{}\", arg);\n}\nfn st(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    sl(\"blue\");\n    st(\"red\".to_string());\n    st(String::from(\"hi\"));\n    st(\"rust is fun!\".to_owned());\n    st(\"nice weather\".into());\n    st(format!(\"Interpolation {}\", \"Station\"));\n    sl(&String::from(\"abc\")[0..1]);\n    sl(\"  hello there \".trim());\n    st(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    st(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n"}

{"wrong_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n", "error": "error[E0603]: function `make_sausage` is private\n  --> exercises/modules/modules1.rs:19:22\n   |\n19 |     sausage_factory::make_sausage();\n   |                      ^^^^^^^^^^^^ private function\n   |\nnote: the function `make_sausage` is defined here\n  --> exercises/modules/modules1.rs:12:5\n   |\n12 |     fn make_sausage() {\n   |     ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    pub fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n"}
{"wrong_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n", "error": "error[E0603]: function `make_sausage` is private\n  --> exercises/modules/modules1.rs:17:22\n   |\n17 |     sausage_factory::make_sausage();\n   |                      ^^^^^^^^^^^^ private function\n   |\nnote: the function `make_sausage` is defined here\n  --> exercises/modules/modules1.rs:10:5\n   |\n10 |     fn make_sausage() {\n   |     ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules1.rs\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -> String {\n        String::from(\"Ginger\")\n    }\n\n    pub fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n"}

{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as ???\n    use self::veggies::CUCUMBER as ???\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/modules/modules2.rs:10:31\n   |\n10 |     use self::fruits::PEAR as ???\n   |                               ^ expected identifier\n\nerror: aborting due to previous error\n\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as ???\n    use self::veggies::CUCUMBER as ???\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected identifier, found `?`\n --> exercises/modules/modules2.rs:9:31\n  |\n9 |     use self::fruits::PEAR as ???\n  |                               ^ expected identifier\n\nerror: aborting due to previous error\n\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit\n    use self::veggies::CUCUMBER as ???\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected `;`, found keyword `use`\n  --> exercises/modules/modules2.rs:9:36\n   |\n9  |     use self::fruits::PEAR as fruit\n   |                                    ^ help: add `;` here\n10 |     use self::veggies::CUCUMBER as ???\n   |     --- unexpected token\n\nerror: expected identifier, found `?`\n  --> exercises/modules/modules2.rs:10:36\n   |\n10 |     use self::veggies::CUCUMBER as ???\n   |                                    ^ expected identifier\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit\n    use self::veggies::CUCUMBER as veggie\n\n    mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected `;`, found keyword `use`\n  --> exercises/modules/modules2.rs:9:36\n   |\n9  |     use self::fruits::PEAR as fruit\n   |                                    ^ help: add `;` here\n10 |     use self::veggies::CUCUMBER as veggie\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `mod`\n  --> exercises/modules/modules2.rs:10:42\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |                                          ^ help: add `;` here\n11 |\n12 |     mod fruits {\n   |     --- unexpected token\n\nerror[E0603]: constant import `fruit` is private\n  --> exercises/modules/modules2.rs:26:27\n   |\n26 |         delicious_snacks::fruit,\n   |                           ^^^^^ private constant import\n   |\nnote: the constant import `fruit` is defined here...\n  --> exercises/modules/modules2.rs:9:9\n   |\n9  |     use self::fruits::PEAR as fruit\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `PEAR` which is defined here\n  --> exercises/modules/modules2.rs:13:9\n   |\n13 |         pub const PEAR: &'static str = \"Pear\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit\n    use self::veggies::CUCUMBER as veggie\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error: expected `;`, found keyword `use`\n  --> exercises/modules/modules2.rs:9:36\n   |\n9  |     use self::fruits::PEAR as fruit\n   |                                    ^ help: add `;` here\n10 |     use self::veggies::CUCUMBER as veggie\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `pub`\n  --> exercises/modules/modules2.rs:10:42\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |                                          ^ help: add `;` here\n11 |\n12 |    pub mod fruits {\n   |    --- unexpected token\n\nerror[E0603]: constant import `fruit` is private\n  --> exercises/modules/modules2.rs:26:27\n   |\n26 |         delicious_snacks::fruit,\n   |                           ^^^^^ private constant import\n   |\nnote: the constant import `fruit` is defined here...\n  --> exercises/modules/modules2.rs:9:9\n   |\n9  |     use self::fruits::PEAR as fruit\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `PEAR` which is defined here\n  --> exercises/modules/modules2.rs:13:9\n   |\n13 |         pub const PEAR: &'static str = \"Pear\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    use self::fruits::PEAR as fruit;\n    use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error[E0603]: constant import `fruit` is private\n  --> exercises/modules/modules2.rs:26:27\n   |\n26 |         delicious_snacks::fruit,\n   |                           ^^^^^ private constant import\n   |\nnote: the constant import `fruit` is defined here...\n  --> exercises/modules/modules2.rs:9:9\n   |\n9  |     use self::fruits::PEAR as fruit;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `PEAR` which is defined here\n  --> exercises/modules/modules2.rs:13:9\n   |\n13 |         pub const PEAR: &'static str = \"Pear\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}
{"wrong_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n    use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n", "error": "error[E0603]: constant import `veggie` is private\n  --> exercises/modules/modules2.rs:27:27\n   |\n27 |         delicious_snacks::veggie\n   |                           ^^^^^^ private constant import\n   |\nnote: the constant import `veggie` is defined here...\n  --> exercises/modules/modules2.rs:10:9\n   |\n10 |     use self::veggies::CUCUMBER as veggie;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...and refers to the constant `CUCUMBER` which is defined here\n  --> exercises/modules/modules2.rs:18:9\n   |\n18 |         pub const CUCUMBER: &'static str = \"Cucumber\";\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0603`.\n", "right_code": "// modules2.rs\n// You can bring module paths into scopes and provide new names for them with the\n// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\npub use self::fruits::PEAR as fruit;\n pub   use self::veggies::CUCUMBER as veggie;\n\n   pub mod fruits {\n        pub const PEAR: &'static str = \"Pear\";\n        pub const APPLE: &'static str = \"Apple\";\n    }\n\npub mod veggies {\n        pub const CUCUMBER: &'static str = \"Cucumber\";\n        pub const CARROT: &'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n"}

{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse ???\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/modules/modules3.rs:11:5\n   |\n11 | use ???\n   |     ^ expected identifier\n\nerror: aborting due to previous error\n\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:14\n   |\n11 | use std::time\n   |              ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared type `SystemTime`\n  --> exercises/modules/modules3.rs:14:11\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |           ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n11 | use time::SystemTime;\n   |\n\nerror[E0425]: cannot find value `UNIX_EPOCH` in this scope\n  --> exercises/modules/modules3.rs:14:44\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |                                            ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this constant\n   |\n11 | use time::UNIX_EPOCH;\n   |\n\nwarning: unused import: `std::time`\n  --> exercises/modules/modules3.rs:11:5\n   |\n11 | use std::time\n   |     ^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time::{}\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:18\n   |\n11 | use std::time::{}\n   |                  ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared type `SystemTime`\n  --> exercises/modules/modules3.rs:14:11\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |           ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n11 | use _::SystemTime;\n   |\n\nerror[E0425]: cannot find value `UNIX_EPOCH` in this scope\n  --> exercises/modules/modules3.rs:14:44\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |                                            ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this constant\n   |\n11 | use _::UNIX_EPOCH;\n   |\n\nwarning: unused import: `std::time::{}`\n  --> exercises/modules/modules3.rs:11:5\n   |\n11 | use std::time::{}\n   |     ^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime}\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:28\n   |\n11 | use std::time::{SystemTime}\n   |                            ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror[E0425]: cannot find value `UNIX_EPOCH` in this scope\n  --> exercises/modules/modules3.rs:14:44\n   |\n14 |     match SystemTime::now().duration_since(UNIX_EPOCH) {\n   |                                            ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this constant\n   |\n11 | use std::time::UNIX_EPOCH;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}
{"wrong_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH}\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n", "error": "error: expected `;`, found keyword `fn`\n  --> exercises/modules/modules3.rs:11:39\n   |\n11 | use std::time::{SystemTime,UNIX_EPOCH}\n   |                                       ^ help: add `;` here\n12 |\n13 | fn main() {\n   | -- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// modules3.rs\n// You can use the 'use' keyword to bring module paths from modules from anywhere\n// and especially from the Rust standard library into your scope.\n// Bring SystemTime and UNIX_EPOCH\n// from the std::time module. Bonus style points if you can do it with one line!\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{SystemTime,UNIX_EPOCH};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n"}

{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        fruit.\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         fruit.\n   |         ^^^^^ expected `()`, found enum `Fruit`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        fruit.entry().\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0599]: no method named `entry` found for enum `Fruit` in the current scope\n  --> exercises/hashmaps/hashmaps2.rs:37:15\n   |\n18 | enum Fruit {\n   | ---------- method `entry` not found for this enum\n...\n37 |         fruit.entry().\n   |               ^^^^^ method not found in `Fruit`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        bak.entry().\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0425]: cannot find value `bak` in this scope\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         bak.entry().\n   |         ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry().\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> exercises/hashmaps/hashmaps2.rs:37:16\n    |\n37  |         basket.entry().\n    |                ^^^^^-- an argument of type `Fruit` is missing\n    |\nnote: associated function defined here\n   --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:854:12\n    |\n854 |     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n    |            ^^^^^\nhelp: provide the argument\n    |\n37  |         basket.entry(/* Fruit */).\n    |                     ~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry().\n   |         ^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found enum `std::collections::hash_map::Entry`\n   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_, Fruit, u32>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(f).\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0425]: cannot find value `f` in this scope\n  --> exercises/hashmaps/hashmaps2.rs:37:22\n   |\n37 |         basket.entry(f).\n   |                      ^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry(f).\n   |         ^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found enum `std::collections::hash_map::Entry`\n   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_, Fruit, u32>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error: unexpected token: `}`\n  --> exercises/hashmaps/hashmaps2.rs:41:5\n   |\n41 |     }\n   |     ^\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry(fruit).\n   |         ^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found enum `std::collections::hash_map::Entry`\n   |\n   = note: expected unit type `()`\n                   found enum `std::collections::hash_map::Entry<'_, Fruit, u32>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error[E0609]: no field `or` on type `std::collections::hash_map::Entry<'_, Fruit, u32>`\n  --> exercises/hashmaps/hashmaps2.rs:37:29\n   |\n37 |         basket.entry(fruit).or\n   |                             ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0609`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert()\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> exercises/hashmaps/hashmaps2.rs:37:29\n     |\n37   |         basket.entry(fruit).or_insert()\n     |                             ^^^^^^^^^-- an argument of type `u32` is missing\n     |\nnote: associated function defined here\n    --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:2533:12\n     |\n2533 |     pub fn or_insert(self, default: V) -> &'a mut V {\n     |            ^^^^^^^^^\nhelp: provide the argument\n     |\n37   |         basket.entry(fruit).or_insert(/* u32 */)\n     |                                      ~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> exercises/hashmaps/hashmaps2.rs:37:9\n   |\n37 |         basket.entry(fruit).or_insert()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n   |         |\n   |         expected `()`, found `&mut u32`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}
{"wrong_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert();\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n", "error": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> exercises/hashmaps/hashmaps2.rs:37:29\n     |\n37   |         basket.entry(fruit).or_insert();\n     |                             ^^^^^^^^^-- an argument of type `u32` is missing\n     |\nnote: associated function defined here\n    --> /home/codespace/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:2533:12\n     |\n2533 |     pub fn or_insert(self, default: V) -> &'a mut V {\n     |            ^^^^^^^^^\nhelp: provide the argument\n     |\n37   |         basket.entry(fruit).or_insert(/* u32 */);\n     |                                      ~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// hashmaps2.rs\n\n// A basket of fruits in the form of a hash map is given. The key\n// represents the name of the fruit and the value represents how many\n// of that particular fruit is in the basket. You have to put *MORE\n// THAN 11* fruits in the basket. Three types of fruits - Apple (4),\n// Mango (2) and Lychee (5) are already given in the basket. You are\n// not allowed to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &mut HashMap<Fruit, u32>) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        \n        basket.entry(fruit).or_insert(2);\n        // TODO: Put new fruits if not already present. Note that you\n        // are not allowed to put any type of fruit that's already\n        // present!\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_fruit_basket() -> HashMap<Fruit, u32> {\n        let mut basket = HashMap::<Fruit, u32>::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds >= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&mut basket);\n        let count = basket.values().sum::<u32>();\n        assert!(count > 11);\n    }\n}\n"}

{"wrong_code": "// strings2.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let word = String::from(\"green\"); // Try not changing this line :)\n    if is_a_color_word(word) {\n        println!(\"That is a color word I know!\");\n    } else {\n        println!(\"That is not a color word I know.\");\n    }\n}\n\nfn is_a_color_word(attempt: &str) -> bool {\n    attempt == \"green\" || attempt == \"blue\" || attempt == \"red\"\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/strings/strings2.rs:9:24\n   |\n9  |     if is_a_color_word(word) {\n   |        --------------- ^^^^\n   |        |               |\n   |        |               expected `&str`, found struct `String`\n   |        |               help: consider borrowing here: `&word`\n   |        arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/strings/strings2.rs:16:4\n   |\n16 | fn is_a_color_word(attempt: &str) -> bool {\n   |    ^^^^^^^^^^^^^^^ -------------\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// strings2.rs\n// Make me compile without changing the function signature!\n// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.\n\n\n\nfn main() {\n    let word = String::from(\"green\"); // Try not changing this line :)\n    if is_a_color_word(&word) {\n        println!(\"That is a color word I know!\");\n    } else {\n        println!(\"That is not a color word I know.\");\n    }\n}\n\nfn is_a_color_word(attempt: &str) -> bool {\n    attempt == \"green\" || attempt == \"blue\" || attempt == \"red\"\n}\n"}


{"wrong_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint...\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().unwrap();\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n", "error": "error: expected one of `(` or `<`, found `...`\n  --> exercises/error_handling/errors6.rs:27:21\n   |\n22 | impl ParsePosNonzeroError {\n   |                           - while parsing this item list starting here\n...\n27 |     fn from_parseint...\n   |                     ^^^ expected one of `(` or `<`\n28 | }\n   | - the item list ends here\n\nerror: aborting due to previous error\n\n", "right_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n"}
{"wrong_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().unwrap();\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_parseint)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n", "error": "error[E0631]: type mismatch in function arguments\n   --> exercises/error_handling/errors6.rs:39:18\n    |\n27  |     fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n    |     ------------------------------------------------------------ found signature defined here\n...\n39  |         .map_err(ParsePosNonzeroError::from_parseint)\n    |          ------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected due to this\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = note: expected function signature `fn(CreationError) -> _`\n               found function signature `fn(ParseIntError) -> _`\nnote: required by a bound in `Result::<T, E>::map_err`\n   --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:858:26\n    |\n858 |     pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T, F> {\n    |                          ^^^^^^^^^^^^^^ required by this bound in `Result::<T, E>::map_err`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0631`.\n", "right_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n"}
{"wrong_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse();\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/error_handling/errors6.rs:37:18\n   |\n37 |     let x: i64 = s.parse();\n   |            ---   ^^^^^^^^^ expected `i64`, found enum `Result`\n   |            |\n   |            expected due to this\n   |\n   = note: expected type `i64`\n              found enum `Result<_, _>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n"}
{"wrong_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x = s.parse();\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/error_handling/errors6.rs:38:33\n   |\n38 |     PositiveNonzeroInteger::new(x)\n   |     --------------------------- ^ expected `i64`, found enum `Result`\n   |     |\n   |     arguments to this function are incorrect\n   |\n   = note: expected type `i64`\n              found enum `Result<_, _>`\nnote: associated function defined here\n  --> exercises/error_handling/errors6.rs:54:8\n   |\n54 |     fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n   |        ^^^ ----------\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// errors6.rs\n\n// Using catch-all error types like `Box<dyn error::Error>` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here,\n// we define a custom error type to make it possible for callers to decide\n// what to do next when our function returns an error.\n\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.\n\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError)\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -> ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &str)\n    -> Result<PositiveNonzeroInteger, ParsePosNonzeroError>\n{\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;\n    PositiveNonzeroInteger::new(x)\n        .map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {\n        match value {\n            x if x < 0 => Err(CreationError::Negative),\n            x if x == 0 => Err(CreationError::Zero),\n            x => Ok(PositiveNonzeroInteger(x as u64))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n"}

{"wrong_code": "// This shopping list program isn't compiling!\n// Use your knowledge of generics to fix it.\n\n// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let mut shopping_list: Vec<?> = Vec::new();\n    shopping_list.push(\"milk\");\n}\n", "error": "error: expected identifier, found `>`\n --> exercises/generics/generics1.rs:9:33\n  |\n9 |     let mut shopping_list: Vec<?> = Vec::new();\n  |         -----------------       ^ expected identifier\n  |         |\n  |         while parsing the type for `mut shopping_list`\n\nerror: aborting due to previous error\n\n", "right_code": "// This shopping list program isn't compiling!\n// Use your knowledge of generics to fix it.\n\n// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let mut shopping_list: Vec<&str> = Vec::new();\n    shopping_list.push(\"milk\");\n}\n"}

{"wrong_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct Wrapper {\n    value: u32,\n}\n\nimpl Wrapper {\n    pub fn new(value: u32) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/generics/generics2.rs:29:33\n   |\n29 |         assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n   |                    ------------ ^^^^^ expected `u32`, found `&str`\n   |                    |\n   |                    arguments to this function are incorrect\n   |\nnote: associated function defined here\n  --> exercises/generics/generics2.rs:13:12\n   |\n13 |     pub fn new(value: u32) -> Self {\n   |            ^^^ ----------\n\nerror[E0308]: mismatched types\n  --> exercises/generics/generics2.rs:29:9\n   |\n29 |         assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `&str`\n   |\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl<T> Wrapper<T> {\n    pub fn new(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n"}
{"wrong_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct Wrapper {\n    value: T,\n}\n\nimpl Wrapper {\n    pub fn new<T>(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n", "error": "error[E0412]: cannot find type `T` in this scope\n --> exercises/generics/generics2.rs:9:12\n  |\n8 | struct Wrapper {\n  |               - help: you might be missing a type parameter: `<T>`\n9 |     value: T,\n  |            ^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0412`.\n", "right_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl<T> Wrapper<T> {\n    pub fn new(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n"}
{"wrong_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl Wrapper {\n    pub fn new<T>(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n", "error": "error[E0107]: missing generics for struct `Wrapper`\n  --> exercises/generics/generics2.rs:12:6\n   |\n12 | impl Wrapper {\n   |      ^^^^^^^ expected 1 generic argument\n   |\nnote: struct defined here, with 1 generic parameter: `T`\n  --> exercises/generics/generics2.rs:8:8\n   |\n8  | struct Wrapper<T> {\n   |        ^^^^^^^ -\nhelp: add missing generic argument\n   |\n12 | impl Wrapper<T> {\n   |      ~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0107`.\n", "right_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl<T> Wrapper<T> {\n    pub fn new(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n"}
{"wrong_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl<T> Wrapper<T> {\n    pub fn new<T>(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n", "error": "error[E0403]: the name `T` is already used for a generic parameter in this item's generic parameters\n  --> exercises/generics/generics2.rs:13:16\n   |\n12 | impl<T> Wrapper<T> {\n   |      - first use of `T`\n13 |     pub fn new<T>(value: T) -> Self {\n   |                ^ already used\n\nerror[E0308]: mismatched types\n  --> exercises/generics/generics2.rs:14:19\n   |\n12 | impl<T> Wrapper<T> {\n   |      - expected type parameter\n13 |     pub fn new<T>(value: T) -> Self {\n   |                - found type parameter\n14 |         Wrapper { value }\n   |                   ^^^^^ expected type parameter `T`, found a different type parameter `T`\n   |\n   = note: expected type parameter `T` (type parameter `T`)\n              found type parameter `T` (type parameter `T`)\n   = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\n   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n\nerror[E0282]: type annotations needed\n  --> exercises/generics/generics2.rs:24:20\n   |\n24 |         assert_eq!(Wrapper::new(42).value, 42);\n   |                    ^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `Wrapper`\n   |\nhelp: consider specifying the generic argument\n   |\n24 |         assert_eq!(Wrapper::<T>::new(42).value, 42);\n   |                           +++++\n\nerror[E0282]: type annotations needed\n  --> exercises/generics/generics2.rs:29:20\n   |\n29 |         assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n   |                    ^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `Wrapper`\n   |\nhelp: consider specifying the generic argument\n   |\n29 |         assert_eq!(Wrapper::<T>::new(\"Foo\").value, \"Foo\");\n   |                           +++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0282, E0308, E0403.\nFor more information about an error, try `rustc --explain E0282`.\n", "right_code": "// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.\n\n\nstruct Wrapper<T> {\n    value: T,\n}\n\nimpl<T> Wrapper<T> {\n    pub fn new(value: T) -> Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n"}

{"wrong_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    //Add your code here\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n", "error": "error[E0046]: not all trait items implemented, missing: `append_bar`\n  --> exercises/traits/traits1.rs:18:1\n   |\n15 |     fn append_bar(self) -> Self;\n   |     ---------------------------- `append_bar` from trait\n...\n18 | impl AppendBar for String {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^ missing `append_bar` in implementation\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0046`.\n", "right_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        let mut x = self.clone();\n        x.push_str(\"Bar\");\n        x\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n"}
{"wrong_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        self.push(\"Bar\").to_string()\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n    --> exercises/traits/traits1.rs:20:19\n     |\n20   |         self.push(\"Bar\").to_string()\n     |              ---- ^^^^^ expected `char`, found `&str`\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1223:12\n     |\n1223 |     pub fn push(&mut self, ch: char) {\n     |            ^^^^\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n  --> exercises/traits/traits1.rs:20:26\n   |\n20 |         self.push(\"Bar\").to_string()\n   |                          ^^^^^^^^^ `()` cannot be formatted with the default formatter\n   |\n   = note: the following trait bounds were not satisfied:\n           `(): std::fmt::Display`\n           which is required by `(): ToString`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n", "right_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        let mut x = self.clone();\n        x.push_str(\"Bar\");\n        x\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n"}
{"wrong_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        self.push_str(\"Bar\").to_string()\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n", "error": "error[E0599]: `()` doesn't implement `std::fmt::Display`\n  --> exercises/traits/traits1.rs:20:30\n   |\n20 |         self.push_str(\"Bar\").to_string()\n   |                              ^^^^^^^^^ `()` cannot be formatted with the default formatter\n   |\n   = note: the following trait bounds were not satisfied:\n           `(): std::fmt::Display`\n           which is required by `(): ToString`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        let mut x = self.clone();\n        x.push_str(\"Bar\");\n        x\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n"}
{"wrong_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        self.push_str(\"Bar\")\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/traits/traits1.rs:20:9\n   |\n19 |     fn append_bar(self) -> Self {\n   |                            ---- expected `String` because of return type\n20 |         self.push_str(\"Bar\")\n   |         ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n  --> exercises/traits/traits1.rs:20:14\n   |\n20 |         self.push_str(\"Bar\")\n   |         ---- ^^^^^^^^ this call modifies `self` in-place\n   |         |\n   |         you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        let mut x = self.clone();\n        x.push_str(\"Bar\");\n        x\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n"}
{"wrong_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        self.push_str(\"Bar\")\n        self\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n", "error": "error: expected `;`, found keyword `self`\n  --> exercises/traits/traits1.rs:20:29\n   |\n20 |         self.push_str(\"Bar\")\n   |                             ^ help: add `;` here\n21 |         self\n   |         ---- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        let mut x = self.clone();\n        x.push_str(\"Bar\");\n        x\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n"}
{"wrong_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        self.push_str(\"Bar\");\n        self\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n", "error": "error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n  --> exercises/traits/traits1.rs:20:9\n   |\n19 |     fn append_bar(self) -> Self {\n   |                   ---- help: consider changing this to be mutable: `mut self`\n20 |         self.push_str(\"Bar\");\n   |         ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0596`.\n", "right_code": "// traits1.rs\n// Time to implement some traits!\n//\n// Your task is to implement the trait\n// `AppendBar' for the type `String'.\n//\n// The trait AppendBar has only one function,\n// which appends \"Bar\" to any object\n// implementing this trait.\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\nimpl AppendBar for String {\n    fn append_bar(self) -> Self {\n        let mut x = self.clone();\n        x.push_str(\"Bar\");\n        x\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n"}

{"wrong_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n", "error": "error[E0599]: no method named `append_bar` found for struct `Vec<String>` in the current scope\n  --> exercises/traits/traits2.rs:28:49\n   |\n28 |         let mut foo = vec![String::from(\"Foo\")].append_bar();\n   |                                                 ^^^^^^^^^^ help: there is a method with a similar name: `append`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `AppendBar` defines an item `append_bar`, perhaps you need to implement it\n  --> exercises/traits/traits2.rs:16:1\n   |\n16 | trait AppendBar {\n   | ^^^^^^^^^^^^^^^\n\nwarning: unused import: `super`\n  --> exercises/traits/traits2.rs:24:9\n   |\n24 |     use super::*;\n   |         ^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec<String> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n"}
{"wrong_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec {\n    fn append_bar(self) -> Self {\n        let mut v = vec![self];\n        v.push(String::from(\"Bar\"));\n        v\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n", "error": "error[E0107]: missing generics for struct `Vec`\n   --> exercises/traits/traits2.rs:21:20\n    |\n21  | impl AppendBar for Vec {\n    |                    ^^^ expected at least 1 generic argument\n    |\nnote: struct defined here, with at least 1 generic parameter: `T`\n   --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:400:12\n    |\n400 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |            ^^^ -\nhelp: add missing generic argument\n    |\n21  | impl AppendBar for Vec<T> {\n    |                    ~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0107`.\n", "right_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec<String> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n"}
{"wrong_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl<T> AppendBar for Vec<T> {\n    fn append_bar(self) -> Self {\n        let mut v = vec![self];\n        v.push(String::from(\"Bar\"));\n        v\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n", "error": "error[E0308]: mismatched types\n    --> exercises/traits/traits2.rs:24:16\n     |\n24   |         v.push(String::from(\"Bar\"));\n     |           ---- ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `String`\n     |           |\n     |           arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<T>`\n                found struct `String`\nnote: associated function defined here\n    --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1829:12\n     |\n1829 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n  --> exercises/traits/traits2.rs:25:9\n   |\n21 | impl<T> AppendBar for Vec<T> {\n   |      - this type parameter\n22 |     fn append_bar(self) -> Self {\n   |                            ---- expected `Vec<T>` because of return type\n...\n25 |         v\n   |         ^ expected type parameter `T`, found struct `Vec`\n   |\n   = note: expected struct `Vec<T>`\n              found struct `Vec<Vec<T>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec<String> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n"}
{"wrong_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl<T> AppendBar for Vec<T> {\n    fn append_bar(self) -> Self {\n        let mut v = self.clone();\n        v.push(String::from(\"Bar\"));\n        v\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n", "error": "error[E0599]: the method `clone` exists for struct `Vec<T>`, but its trait bounds were not satisfied\n   --> exercises/traits/traits2.rs:23:26\n    |\n23  |         let mut v = self.clone();\n    |                          ^^^^^ method cannot be called on `Vec<T>` due to unsatisfied trait bounds\n    |\n   ::: /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:400:1\n    |\n400 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<T>: Clone`\n    |\n    = note: the following trait bounds were not satisfied:\n            `T: Clone`\n            which is required by `Vec<T>: Clone`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec<String> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n"}
{"wrong_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl<T> AppendBar for Vec<T> {\n    fn append_bar(self) -> Self {\n        let mut v = self.copy();\n        v.push(String::from(\"Bar\"));\n        v\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n", "error": "error[E0599]: no method named `copy` found for struct `Vec<T>` in the current scope\n  --> exercises/traits/traits2.rs:23:26\n   |\n23 |         let mut v = self.copy();\n   |                          ^^^^ method not found in `Vec<T>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec<String> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n"}
{"wrong_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl<T> AppendBar for Vec<T> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n", "error": "error[E0308]: mismatched types\n    --> exercises/traits/traits2.rs:23:19\n     |\n21   | impl<T> AppendBar for Vec<T> {\n     |      - this type parameter\n22   |     fn append_bar(mut self) -> Self {\n23   |         self.push(String::from(\"Bar\"));\n     |              ---- ^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found struct `String`\n     |              |\n     |              arguments to this function are incorrect\n     |\n     = note: expected type parameter `T`\n                        found struct `String`\nnote: associated function defined here\n    --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1829:12\n     |\n1829 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// traits2.rs\n//\n// Your task is to implement the trait\n// `AppendBar' for a vector of strings.\n//\n// To implement this trait, consider for\n// a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time,\n// you can do this!\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -> Self;\n}\n\n//TODO: Add your code here\nimpl AppendBar for Vec<String> {\n    fn append_bar(mut self) -> Self {\n        self.push(String::from(\"Bar\"));\n        self\n\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n"}

{"wrong_code": "// traits3.rs\n//\n// Your task is to implement the Licensed trait for\n// both structures and have them return the same\n// information without writing the same function twice.\n//\n// Consider what you can add to the Licensed trait.\n// Execute `rustlings hint traits3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub trait Licensed {\n    fn licensing_info(&self) -> String;\n}\n\nstruct SomeSoftware {\n    version_number: i32,\n}\n\nstruct OtherSoftware {\n    version_number: String,\n}\n\nimpl Licensed for SomeSoftware {} // Don't edit this line\nimpl Licensed for OtherSoftware {} // Don't edit this line\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_licensing_info_the_same() {\n        let licensing_info = String::from(\"Some information\");\n        let some_software = SomeSoftware { version_number: 1 };\n        let other_software = OtherSoftware {\n            version_number: \"v2.0.0\".to_string(),\n        };\n        assert_eq!(some_software.licensing_info(), licensing_info);\n        assert_eq!(other_software.licensing_info(), licensing_info);\n    }\n}\n", "error": "error[E0046]: not all trait items implemented, missing: `licensing_info`\n  --> exercises/traits/traits3.rs:24:1\n   |\n13 |     fn licensing_info(&self) -> String;\n   |     ----------------------------------- `licensing_info` from trait\n...\n24 | impl Licensed for SomeSoftware {} // Don't edit this line\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `licensing_info` in implementation\n\nerror[E0046]: not all trait items implemented, missing: `licensing_info`\n  --> exercises/traits/traits3.rs:25:1\n   |\n13 |     fn licensing_info(&self) -> String;\n   |     ----------------------------------- `licensing_info` from trait\n...\n25 | impl Licensed for OtherSoftware {} // Don't edit this line\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `licensing_info` in implementation\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0046`.\n", "right_code": "// traits3.rs\n//\n// Your task is to implement the Licensed trait for\n// both structures and have them return the same\n// information without writing the same function twice.\n//\n// Consider what you can add to the Licensed trait.\n// Execute `rustlings hint traits3` or use the `hint` watch subcommand for a hint.\n\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        String::from(\"Some information\")\n    }\n}\n\nstruct SomeSoftware {\n    version_number: i32,\n}\n\nstruct OtherSoftware {\n    version_number: String,\n}\n\nimpl Licensed for SomeSoftware {} // Don't edit this line\nimpl Licensed for OtherSoftware {} // Don't edit this line\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_licensing_info_the_same() {\n        let licensing_info = String::from(\"Some information\");\n        let some_software = SomeSoftware { version_number: 1 };\n        let other_software = OtherSoftware {\n            version_number: \"v2.0.0\".to_string(),\n        };\n        assert_eq!(some_software.licensing_info(), licensing_info);\n        assert_eq!(other_software.licensing_info(), licensing_info);\n    }\n}\n"}

{"wrong_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: ??, software_two: ??) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/traits/traits4.rs:23:37\n   |\n23 | fn compare_license_types(software: ??, software_two: ??) -> bool {\n   |                                     ^ expected identifier\n\nerror: expected identifier, found `?`\n  --> exercises/traits/traits4.rs:23:55\n   |\n23 | fn compare_license_types(software: ??, software_two: ??) -> bool {\n   |                                                       ^ expected identifier\n\nerror[E0425]: cannot find value `software` in this scope\n  --> exercises/traits/traits4.rs:24:5\n   |\n24 |     software.licensing_info() == software_two.licensing_info()\n   |     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `software_two` in this scope\n  --> exercises/traits/traits4.rs:24:34\n   |\n24 |     software.licensing_info() == software_two.licensing_info()\n   |                                  ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: impl Licensed, software_two: impl Licensed) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n"}
{"wrong_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: SomeSoftware, software_two: OtherSoftware) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n", "error": "error[E0308]: arguments to this function are incorrect\n  --> exercises/traits/traits4.rs:44:17\n   |\n44 |         assert!(compare_license_types(other_software, some_software));\n   |                 ^^^^^^^^^^^^^^^^^^^^^ --------------  ------------- expected `OtherSoftware`, found `SomeSoftware`\n   |                                       |\n   |                                       expected `SomeSoftware`, found `OtherSoftware`\n   |\nnote: function defined here\n  --> exercises/traits/traits4.rs:23:4\n   |\n23 | fn compare_license_types(software: SomeSoftware, software_two: OtherSoftware) -> bool {\n   |    ^^^^^^^^^^^^^^^^^^^^^ ----------------------  ---------------------------\nhelp: swap these arguments\n   |\n44 |         assert!(compare_license_types(some_software, other_software));\n   |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: impl Licensed, software_two: impl Licensed) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n"}
{"wrong_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: OtherSoftware, software_two: SomeSoftware) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n", "error": "error[E0308]: arguments to this function are incorrect\n  --> exercises/traits/traits4.rs:36:17\n   |\n36 |         assert!(compare_license_types(some_software, other_software));\n   |                 ^^^^^^^^^^^^^^^^^^^^^ -------------  -------------- expected `SomeSoftware`, found `OtherSoftware`\n   |                                       |\n   |                                       expected `OtherSoftware`, found `SomeSoftware`\n   |\nnote: function defined here\n  --> exercises/traits/traits4.rs:23:4\n   |\n23 | fn compare_license_types(software: OtherSoftware, software_two: SomeSoftware) -> bool {\n   |    ^^^^^^^^^^^^^^^^^^^^^ -----------------------  --------------------------\nhelp: swap these arguments\n   |\n36 |         assert!(compare_license_types(other_software, some_software));\n   |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: impl Licensed, software_two: impl Licensed) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n"}
{"wrong_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types<T: Licensed>(software: T, software_two: T) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/traits/traits4.rs:36:54\n   |\n36 |         assert!(compare_license_types(some_software, other_software));\n   |                 ---------------------                ^^^^^^^^^^^^^^ expected struct `SomeSoftware`, found struct `OtherSoftware`\n   |                 |\n   |                 arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/traits/traits4.rs:23:4\n   |\n23 | fn compare_license_types<T: Licensed>(software: T, software_two: T) -> bool {\n   |    ^^^^^^^^^^^^^^^^^^^^^                           ---------------\n\nerror[E0308]: mismatched types\n  --> exercises/traits/traits4.rs:44:55\n   |\n44 |         assert!(compare_license_types(other_software, some_software));\n   |                 ---------------------                 ^^^^^^^^^^^^^ expected struct `OtherSoftware`, found struct `SomeSoftware`\n   |                 |\n   |                 arguments to this function are incorrect\n   |\nnote: function defined here\n  --> exercises/traits/traits4.rs:23:4\n   |\n23 | fn compare_license_types<T: Licensed>(software: T, software_two: T) -> bool {\n   |    ^^^^^^^^^^^^^^^^^^^^^                           ---------------\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.\n\n\npub trait Licensed {\n    fn licensing_info(&self) -> String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types(software: impl Licensed, software_two: impl Licensed) -> bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n"}

{"wrong_code": "// traits5.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits5` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub trait SomeTrait {\n    fn some_function(&self) -> bool {\n        true\n    }\n}\n\npub trait OtherTrait {\n    fn other_function(&self) -> bool {\n        true\n    }\n}\n\nstruct SomeStruct {}\nstruct OtherStruct {}\n\nimpl SomeTrait for SomeStruct {}\nimpl OtherTrait for SomeStruct {}\nimpl SomeTrait for OtherStruct {}\nimpl OtherTrait for OtherStruct {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn some_func(item: ??) -> bool {\n    item.some_function() && item.other_function()\n}\n\nfn main() {\n    some_func(SomeStruct {});\n    some_func(OtherStruct {});\n}\n", "error": "error: expected identifier, found `?`\n  --> exercises/traits/traits5.rs:30:21\n   |\n30 | fn some_func(item: ??) -> bool {\n   |                     ^ expected identifier\n\nerror[E0425]: cannot find value `item` in this scope\n  --> exercises/traits/traits5.rs:31:5\n   |\n31 |     item.some_function() && item.other_function()\n   |     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `item` in this scope\n  --> exercises/traits/traits5.rs:31:29\n   |\n31 |     item.some_function() && item.other_function()\n   |                             ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// traits5.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n// Don't change any line other than the marked one.\n// Execute `rustlings hint traits5` or use the `hint` watch subcommand for a hint.\n\n\npub trait SomeTrait {\n    fn some_function(&self) -> bool {\n        true\n    }\n}\n\npub trait OtherTrait {\n    fn other_function(&self) -> bool {\n        true\n    }\n}\n\nstruct SomeStruct {}\nstruct OtherStruct {}\n\nimpl SomeTrait for SomeStruct {}\nimpl OtherTrait for SomeStruct {}\nimpl SomeTrait for OtherStruct {}\nimpl OtherTrait for OtherStruct {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn some_func<T: SomeTrait+OtherTrait>(item: T) -> bool {\n    item.some_function() && item.other_function()\n}\n\nfn main() {\n    some_func(SomeStruct {});\n    some_func(OtherStruct {});\n}\n"}

{"wrong_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.grade < 12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/quiz3.rs:27:26\n   |\n27 |         if &self.grade < 12 {\n   |                          ^^ expected `&f32`, found integer\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.student_age < &12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n"}
{"wrong_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.grade < &12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/quiz3.rs:27:26\n   |\n27 |         if &self.grade < &12 {\n   |                          ^^^ expected `f32`, found integer\n   |\n   = note: expected reference `&f32`\n              found reference `&{integer}`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.student_age < &12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n"}
{"wrong_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.student_age < &12.0 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/quiz3.rs:27:32\n   |\n27 |         if &self.student_age < &12.0 {\n   |                                ^^^^^ expected `u8`, found floating-point number\n   |\n   = note: expected reference `&u8`\n              found reference `&{float}`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.student_age < &12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n"}
{"wrong_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.student_age < 12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/quiz3.rs:27:32\n   |\n27 |         if &self.student_age < 12 {\n   |                                ^^\n   |                                |\n   |                                expected `&u8`, found integer\n   |                                help: consider borrowing here: `&12`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// quiz3.rs\n// This quiz tests:\n// - Generics\n// - Traits\n// An imaginary magical school has a new report card generation system written in Rust!\n// Currently the system only supports creating report cards where the student's grade\n// is represented numerically (e.g. 1.0 -> 5.5).\n// However, the school also issues alphabetical grades (A+ -> F-) and needs\n// to be able to print both types of report card!\n\n// Make the necessary code changes in the struct ReportCard and the impl block\n// to support alphabetical report cards. Change the Grade in the second test to \"A+\"\n// to show that your changes allow alphabetical grades.\n\n// Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.\n\n\npub struct ReportCard {\n    pub grade: f32,\n    pub student_name: String,\n    pub student_age: u8,\n}\n\nimpl ReportCard {\n    pub fn print(&self) -> String {\n        if &self.student_age < &12 {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, \"A+\")\n        } else {\n        format!(\"{} ({}) - achieved a grade of {}\",\n            &self.student_name, &self.student_age, &self.grade)\n\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_numeric_report_card() {\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Tom Wriggle\".to_string(),\n            student_age: 12,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Tom Wriggle (12) - achieved a grade of 2.1\"\n        );\n    }\n\n    #[test]\n    fn generate_alphabetic_report_card() {\n        // TODO: Make sure to change the grade here after you finish the exercise.\n        let report_card = ReportCard {\n            grade: 2.1,\n            student_name: \"Gary Plotter\".to_string(),\n            student_age: 11,\n        };\n        assert_eq!(\n            report_card.print(),\n            \"Gary Plotter (11) - achieved a grade of A+\"\n        );\n    }\n}\n"}

{"wrong_code": "// tests1.rs\n// Tests are important to ensure that your code does what you think it should do.\n// Tests can be run on this file with the following command:\n// rustlings run tests1\n\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!();\n    }\n}\n", "error": "error: macro requires a boolean expression as an argument\n  --> exercises/tests/tests1.rs:16:9\n   |\n16 |         assert!();\n   |         ^^^^^^^^^ boolean expression required\n\nerror: aborting due to previous error\n\n", "right_code": "// tests1.rs\n// Tests are important to ensure that your code does what you think it should do.\n// Tests can be run on this file with the following command:\n// rustlings run tests1\n\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!(1==1,true);\n    }\n}\n"}
{"wrong_code": "// tests1.rs\n// Tests are important to ensure that your code does what you think it should do.\n// Tests can be run on this file with the following command:\n// rustlings run tests1\n\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!(1,1);\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/tests/tests1.rs:16:9\n   |\n16 |         assert!(1,1);\n   |         ^^^^^^^^^^^^ expected `bool`, found integer\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// tests1.rs\n// Tests are important to ensure that your code does what you think it should do.\n// Tests can be run on this file with the following command:\n// rustlings run tests1\n\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!(1==1,true);\n    }\n}\n"}
{"wrong_code": "// tests1.rs\n// Tests are important to ensure that your code does what you think it should do.\n// Tests can be run on this file with the following command:\n// rustlings run tests1\n\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!(1==1,Ok());\n    }\n}\n", "error": "error[E0061]: this enum variant takes 1 argument but 0 arguments were supplied\n   --> exercises/tests/tests1.rs:16:22\n    |\n16  |         assert!(1==1,Ok());\n    |                      ^^-- an argument is missing\n    |\nnote: tuple variant defined here\n   --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:508:5\n    |\n508 |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^\nhelp: provide the argument\n    |\n16  |         assert!(1==1,Ok(/* value */));\n    |                        ~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n", "right_code": "// tests1.rs\n// Tests are important to ensure that your code does what you think it should do.\n// Tests can be run on this file with the following command:\n// rustlings run tests1\n\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!(1==1,true);\n    }\n}\n"}

{"wrong_code": "// tests2.rs\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert_eq() {\n        assert_eq!();\n    }\n}\n", "error": "error: unexpected end of macro invocation\n  --> exercises/tests/tests2.rs:12:9\n   |\n12 |         assert_eq!();\n   |         ^^^^^^^^^^^^ missing tokens in macro arguments\n\nerror: aborting due to previous error\n\n", "right_code": "// tests2.rs\n// This test has a problem with it -- make the test compile! Make the test\n// pass! Make the test fail!\n// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert_eq() {\n        assert_eq!(1,1);\n    }\n}\n"}

{"wrong_code": "// tests3.rs\n// This test isn't testing our function -- make it do that in such a way that\n// the test passes. Then write a second test that tests whether we get the result\n// we expect to get when we call `is_even(5)`.\n// Execute `rustlings hint tests3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn is_even(num: i32) -> bool {\n    num % 2 == 0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_true_when_even() {\n        assert!();\n    }\n\n    #[test]\n    fn is_false_when_odd() {\n        assert!();\n    }\n}\n", "error": "error: macro requires a boolean expression as an argument\n  --> exercises/tests/tests3.rs:19:9\n   |\n19 |         assert!();\n   |         ^^^^^^^^^ boolean expression required\n\nerror: macro requires a boolean expression as an argument\n  --> exercises/tests/tests3.rs:24:9\n   |\n24 |         assert!();\n   |         ^^^^^^^^^ boolean expression required\n\nwarning: unused import: `super::*`\n  --> exercises/tests/tests3.rs:15:9\n   |\n15 |     use super::*;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n", "right_code": "// tests3.rs\n// This test isn't testing our function -- make it do that in such a way that\n// the test passes. Then write a second test that tests whether we get the result\n// we expect to get when we call `is_even(5)`.\n// Execute `rustlings hint tests3` or use the `hint` watch subcommand for a hint.\n\n\npub fn is_even(num: i32) -> bool {\n    num % 2 == 0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_true_when_even() {\n        assert!(is_even(2), true);\n    }\n\n    #[test]\n    fn is_false_when_odd() {\n        assert_eq!(is_even(3), false);\n    }\n}\n"}

{"wrong_code": "// lifetimes1.rs\n//\n// The Rust compiler needs to know how to check whether supplied references are\n// valid, so that it can let the programmer know if a reference is at risk\n// of going out of scope before it is used. Remember, references are borrows\n// and do not own their own data. What if their owner goes out of scope?\n//\n// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is '{}'\", result);\n}\n", "error": "error[E0106]: missing lifetime specifier\n  --> exercises/lifetimes/lifetimes1.rs:12:33\n   |\n12 | fn longest(x: &str, y: &str) -> &str {\n   |               ----     ----     ^ expected named lifetime parameter\n   |\n   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\nhelp: consider introducing a named lifetime parameter\n   |\n12 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n   |           ++++     ++          ++          ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0106`.\n", "right_code": "// lifetimes1.rs\n//\n// The Rust compiler needs to know how to check whether supplied references are\n// valid, so that it can let the programmer know if a reference is at risk\n// of going out of scope before it is used. Remember, references are borrows\n// and do not own their own data. What if their owner goes out of scope?\n//\n// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.\n\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is '{}'\", result);\n}\n"}
{"wrong_code": "// lifetimes1.rs\n//\n// The Rust compiler needs to know how to check whether supplied references are\n// valid, so that it can let the programmer know if a reference is at risk\n// of going out of scope before it is used. Remember, references are borrows\n// and do not own their own data. What if their owner goes out of scope?\n//\n// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn longest(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is '{}'\", result);\n}\n", "error": "error[E0261]: use of undeclared lifetime name `'a`\n  --> exercises/lifetimes/lifetimes1.rs:12:16\n   |\n12 | fn longest(x: &'a str, y: &'a str) -> &'a str {\n   |           -    ^^ undeclared lifetime\n   |           |\n   |           help: consider introducing lifetime `'a` here: `<'a>`\n\nerror[E0261]: use of undeclared lifetime name `'a`\n  --> exercises/lifetimes/lifetimes1.rs:12:28\n   |\n12 | fn longest(x: &'a str, y: &'a str) -> &'a str {\n   |           -                ^^ undeclared lifetime\n   |           |\n   |           help: consider introducing lifetime `'a` here: `<'a>`\n\nerror[E0261]: use of undeclared lifetime name `'a`\n  --> exercises/lifetimes/lifetimes1.rs:12:40\n   |\n12 | fn longest(x: &'a str, y: &'a str) -> &'a str {\n   |           -                            ^^ undeclared lifetime\n   |           |\n   |           help: consider introducing lifetime `'a` here: `<'a>`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0261`.\n", "right_code": "// lifetimes1.rs\n//\n// The Rust compiler needs to know how to check whether supplied references are\n// valid, so that it can let the programmer know if a reference is at risk\n// of going out of scope before it is used. Remember, references are borrows\n// and do not own their own data. What if their owner goes out of scope?\n//\n// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.\n\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is '{}'\", result);\n}\n"}

{"wrong_code": "// lifetimes2.rs\n//\n// So if the compiler is just validating the references passed\n// to the annotated parameters and the return type, what do\n// we need to change?\n//\n// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is '{}'\", result);\n}\n", "error": "error[E0597]: `string2` does not live long enough\n  --> exercises/lifetimes/lifetimes2.rs:24:44\n   |\n24 |         result = longest(string1.as_str(), string2.as_str());\n   |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n25 |     }\n   |     - `string2` dropped here while still borrowed\n26 |     println!(\"The longest string is '{}'\", result);\n   |                                            ------ borrow later used here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0597`.\n", "right_code": "// lifetimes2.rs\n//\n// So if the compiler is just validating the references passed\n// to the annotated parameters and the return type, what do\n// we need to change?\n//\n// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.\n\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is '{}'\", result);\n    }\n}\n"}

{"wrong_code": "// lifetimes3.rs\n//\n// Lifetimes are also needed when structs hold references.\n//\n// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct Book {\n    author: &str,\n    title: &str,\n}\n\nfn main() {\n    let name = String::from(\"Jill Smith\");\n    let title = String::from(\"Fish Flying\");\n    let book = Book { author: &name, title: &title };\n\n    println!(\"{} by {}\", book.title, book.author);\n}\n", "error": "error[E0106]: missing lifetime specifier\n  --> exercises/lifetimes/lifetimes3.rs:10:13\n   |\n10 |     author: &str,\n   |             ^ expected named lifetime parameter\n   |\nhelp: consider introducing a named lifetime parameter\n   |\n9  ~ struct Book<'a> {\n10 ~     author: &'a str,\n   |\n\nerror[E0106]: missing lifetime specifier\n  --> exercises/lifetimes/lifetimes3.rs:11:12\n   |\n11 |     title: &str,\n   |            ^ expected named lifetime parameter\n   |\nhelp: consider introducing a named lifetime parameter\n   |\n9  ~ struct Book<'a> {\n10 |     author: &str,\n11 ~     title: &'a str,\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0106`.\n", "right_code": "// lifetimes3.rs\n//\n// Lifetimes are also needed when structs hold references.\n//\n// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.\n\n\nstruct Book<'a> {\n    author: &'a str,\n    title: &'a str,\n}\n\nfn main() {\n    let name = String::from(\"Jill Smith\");\n    let title = String::from(\"Fish Flying\");\n    let book = Book { author: &name, title: &title };\n\n    println!(\"{} by {}\", book.title, book.author);\n}\n"}
{"wrong_code": "// lifetimes3.rs\n//\n// Lifetimes are also needed when structs hold references.\n//\n// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nstruct Book<'a> {\n    author: &str,\n    title: &'a str,\n}\n\nfn main() {\n    let name = String::from(\"Jill Smith\");\n    let title = String::from(\"Fish Flying\");\n    let book = Book { author: &name, title: &title };\n\n    println!(\"{} by {}\", book.title, book.author);\n}\n", "error": "error[E0106]: missing lifetime specifier\n  --> exercises/lifetimes/lifetimes3.rs:10:13\n   |\n10 |     author: &str,\n   |             ^ expected named lifetime parameter\n   |\nhelp: consider using the `'a` lifetime\n   |\n10 |     author: &'a str,\n   |              ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0106`.\n", "right_code": "// lifetimes3.rs\n//\n// Lifetimes are also needed when structs hold references.\n//\n// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.\n\n\nstruct Book<'a> {\n    author: &'a str,\n    title: &'a str,\n}\n\nfn main() {\n    let name = String::from(\"Jill Smith\");\n    let title = String::from(\"Fish Flying\");\n    let book = Book { author: &name, title: &title };\n\n    println!(\"{} by {}\", book.title, book.author);\n}\n"}

{"wrong_code": "// iterators1.rs\n//\n//  Make me compile by filling in the `???`s\n//\n// When performing operations on elements within a collection, iterators are essential.\n// This module helps you get familiar with the structure of using an iterator and\n// how to go through elements within an iterable collection.\n//\n// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main () {\n    let my_fav_fruits = vec![\"banana\", \"custard apple\", \"avocado\", \"peach\", \"raspberry\"];\n\n    let mut my_iterable_fav_fruits = ???;   // TODO: Step 1\n\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"banana\"));\n    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"avocado\"));\n    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 3\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"raspberry\"));\n    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 4\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/standard_library_types/iterators1.rs:16:38\n   |\n16 |     let mut my_iterable_fav_fruits = ???;   // TODO: Step 1\n   |                                      ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// iterators1.rs\n//\n//  Make me compile by filling in the `???`s\n//\n// When performing operations on elements within a collection, iterators are essential.\n// This module helps you get familiar with the structure of using an iterator and\n// how to go through elements within an iterable collection.\n//\n// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.\n\n\nfn main () {\n    let my_fav_fruits = vec![\"banana\", \"custard apple\", \"avocado\", \"peach\", \"raspberry\"];\n\n    let mut my_iterable_fav_fruits = my_fav_fruits.iter().copied();   // TODO: Step 1\n\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"banana\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"custard apple\"));     // TODO: Step 2\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"avocado\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"peach\"));     // TODO: Step 3\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"raspberry\"));\n    assert_eq!(my_iterable_fav_fruits.next(), None);     // TODO: Step 4\n}\n"}
{"wrong_code": "// iterators1.rs\n//\n//  Make me compile by filling in the `???`s\n//\n// When performing operations on elements within a collection, iterators are essential.\n// This module helps you get familiar with the structure of using an iterator and\n// how to go through elements within an iterable collection.\n//\n// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main () {\n    let my_fav_fruits = vec![\"banana\", \"custard apple\", \"avocado\", \"peach\", \"raspberry\"];\n\n    let mut my_iterable_fav_fruits = my_fav_fruits.iter().copied();   // TODO: Step 1\n\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"banana\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"custard apple\"));     // TODO: Step 2\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"avocado\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"peach\"));     // TODO: Step 3\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&\"raspberry\"));\n    assert_eq!(my_iterable_fav_fruits.next(), None);     // TODO: Step 4\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/standard_library_types/iterators1.rs:18:5\n   |\n18 |     assert_eq!(my_iterable_fav_fruits.next(), Some(&\"banana\"));\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |\n   = note: expected enum `Option<&str>`\n              found enum `Option<&&str>`\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: use `Option::copied` to copy the value inside the `Option`\n  --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:40:45\n   |\n40 |                 if !(*left_val == *right_val.copied()) {\n   |                                             +++++++++\n\nerror[E0308]: mismatched types\n  --> exercises/standard_library_types/iterators1.rs:19:5\n   |\n19 |     assert_eq!(my_iterable_fav_fruits.next(), Some(&\"custard apple\"));     // TODO: Step 2\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |\n   = note: expected enum `Option<&str>`\n              found enum `Option<&&str>`\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: use `Option::copied` to copy the value inside the `Option`\n  --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:40:45\n   |\n40 |                 if !(*left_val == *right_val.copied()) {\n   |                                             +++++++++\n\nerror[E0308]: mismatched types\n  --> exercises/standard_library_types/iterators1.rs:20:5\n   |\n20 |     assert_eq!(my_iterable_fav_fruits.next(), Some(&\"avocado\"));\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |\n   = note: expected enum `Option<&str>`\n              found enum `Option<&&str>`\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: use `Option::copied` to copy the value inside the `Option`\n  --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:40:45\n   |\n40 |                 if !(*left_val == *right_val.copied()) {\n   |                                             +++++++++\n\nerror[E0308]: mismatched types\n  --> exercises/standard_library_types/iterators1.rs:21:5\n   |\n21 |     assert_eq!(my_iterable_fav_fruits.next(), Some(&\"peach\"));     // TODO: Step 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |\n   = note: expected enum `Option<&str>`\n              found enum `Option<&&str>`\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: use `Option::copied` to copy the value inside the `Option`\n  --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:40:45\n   |\n40 |                 if !(*left_val == *right_val.copied()) {\n   |                                             +++++++++\n\nerror[E0308]: mismatched types\n  --> exercises/standard_library_types/iterators1.rs:22:5\n   |\n22 |     assert_eq!(my_iterable_fav_fruits.next(), Some(&\"raspberry\"));\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `&str`\n   |\n   = note: expected enum `Option<&str>`\n              found enum `Option<&&str>`\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: use `Option::copied` to copy the value inside the `Option`\n  --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:40:45\n   |\n40 |                 if !(*left_val == *right_val.copied()) {\n   |                                             +++++++++\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// iterators1.rs\n//\n//  Make me compile by filling in the `???`s\n//\n// When performing operations on elements within a collection, iterators are essential.\n// This module helps you get familiar with the structure of using an iterator and\n// how to go through elements within an iterable collection.\n//\n// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.\n\n\nfn main () {\n    let my_fav_fruits = vec![\"banana\", \"custard apple\", \"avocado\", \"peach\", \"raspberry\"];\n\n    let mut my_iterable_fav_fruits = my_fav_fruits.iter().copied();   // TODO: Step 1\n\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"banana\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"custard apple\"));     // TODO: Step 2\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"avocado\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"peach\"));     // TODO: Step 3\n    assert_eq!(my_iterable_fav_fruits.next(), Some(\"raspberry\"));\n    assert_eq!(my_iterable_fav_fruits.next(), None);     // TODO: Step 4\n}\n"}

{"wrong_code": "// iterators2.rs\n// In this exercise, you'll learn some of the unique advantages that iterators\n// can offer. Follow the steps to complete the exercise.\n// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// Step 1.\n// Complete the `capitalize_first` function.\n// \"hello\" -> \"Hello\"\npub fn capitalize_first(input: &str) -> String {\n    let mut c = input.chars();\n    match c.next() {\n        None => String::new(),\n        Some(first) => ???,\n    }\n}\n\n// Step 2.\n// Apply the `capitalize_first` function to a slice of string slices.\n// Return a vector of strings.\n// [\"hello\", \"world\"] -> [\"Hello\", \"World\"]\npub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {\n    vec![]\n}\n\n// Step 3.\n// Apply the `capitalize_first` function again to a slice of string slices.\n// Return a single string.\n// [\"hello\", \" \", \"world\"] -> \"Hello World\"\npub fn capitalize_words_string(words: &[&str]) -> String {\n    String::new()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_success() {\n        assert_eq!(capitalize_first(\"hello\"), \"Hello\");\n    }\n\n    #[test]\n    fn test_empty() {\n        assert_eq!(capitalize_first(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_iterate_string_vec() {\n        let words = vec![\"hello\", \"world\"];\n        assert_eq!(capitalize_words_vector(&words), [\"Hello\", \"World\"]);\n    }\n\n    #[test]\n    fn test_iterate_into_string() {\n        let words = vec![\"hello\", \" \", \"world\"];\n        assert_eq!(capitalize_words_string(&words), \"Hello World\");\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/standard_library_types/iterators2.rs:15:24\n   |\n15 |         Some(first) => ???,\n   |                     -- ^ expected expression\n   |                     |\n   |                     while parsing the `match` arm starting here\n\nerror: aborting due to previous error\n\n", "right_code": "// iterators2.rs\n// In this exercise, you'll learn some of the unique advantages that iterators\n// can offer. Follow the steps to complete the exercise.\n// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.\n\n\n// Step 1.\n// Complete the `capitalize_first` function.\n// \"hello\" -> \"Hello\"\npub fn capitalize_first(input: &str) -> String {\n    let mut c = input.chars();\n    match c.next() {\n        None => String::new(),\n        Some(first) => first.to_uppercase().to_string() + c.as_str(),\n    }\n}\n\n// Step 2.\n// Apply the `capitalize_first` function to a slice of string slices.\n// Return a vector of strings.\n// [\"hello\", \"world\"] -> [\"Hello\", \"World\"]\npub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {\n    words.iter().map(|x| capitalize_first(x)).collect()\n}\n\n// Step 3.\n// Apply the `capitalize_first` function again to a slice of string slices.\n// Return a single string.\n// [\"hello\", \" \", \"world\"] -> \"Hello World\"\npub fn capitalize_words_string(words: &[&str]) -> String {\n    words.iter().map(|x| capitalize_first(x)).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_success() {\n        assert_eq!(capitalize_first(\"hello\"), \"Hello\");\n    }\n\n    #[test]\n    fn test_empty() {\n        assert_eq!(capitalize_first(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_iterate_string_vec() {\n        let words = vec![\"hello\", \"world\"];\n        assert_eq!(capitalize_words_vector(&words), [\"Hello\", \"World\"]);\n    }\n\n    #[test]\n    fn test_iterate_into_string() {\n        let words = vec![\"hello\", \" \", \"world\"];\n        assert_eq!(capitalize_words_string(&words), \"Hello World\");\n    }\n}\n"}
{"wrong_code": "// iterators2.rs\n// In this exercise, you'll learn some of the unique advantages that iterators\n// can offer. Follow the steps to complete the exercise.\n// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n// Step 1.\n// Complete the `capitalize_first` function.\n// \"hello\" -> \"Hello\"\npub fn capitalize_first(input: &str) -> String {\n    let mut c = input.chars();\n    match c.next() {\n        None => String::new(),\n        Some(first) => first.to_uppercase(),\n    }\n}\n\n// Step 2.\n// Apply the `capitalize_first` function to a slice of string slices.\n// Return a vector of strings.\n// [\"hello\", \"world\"] -> [\"Hello\", \"World\"]\npub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {\n    vec![]\n}\n\n// Step 3.\n// Apply the `capitalize_first` function again to a slice of string slices.\n// Return a single string.\n// [\"hello\", \" \", \"world\"] -> \"Hello World\"\npub fn capitalize_words_string(words: &[&str]) -> String {\n    String::new()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_success() {\n        assert_eq!(capitalize_first(\"hello\"), \"Hello\");\n    }\n\n    #[test]\n    fn test_empty() {\n        assert_eq!(capitalize_first(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_iterate_string_vec() {\n        let words = vec![\"hello\", \"world\"];\n        assert_eq!(capitalize_words_vector(&words), [\"Hello\", \"World\"]);\n    }\n\n    #[test]\n    fn test_iterate_into_string() {\n        let words = vec![\"hello\", \" \", \"world\"];\n        assert_eq!(capitalize_words_string(&words), \"Hello World\");\n    }\n}\n", "error": "error[E0308]: `match` arms have incompatible types\n  --> exercises/standard_library_types/iterators2.rs:15:24\n   |\n13 | /     match c.next() {\n14 | |         None => String::new(),\n   | |                 ------------- this is found to be of type `String`\n15 | |         Some(first) => first.to_uppercase(),\n   | |                        ^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   | |                        |\n   | |                        expected struct `String`, found struct `ToUppercase`\n16 | |     }\n   | |_____- `match` arms have incompatible types\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// iterators2.rs\n// In this exercise, you'll learn some of the unique advantages that iterators\n// can offer. Follow the steps to complete the exercise.\n// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.\n\n\n// Step 1.\n// Complete the `capitalize_first` function.\n// \"hello\" -> \"Hello\"\npub fn capitalize_first(input: &str) -> String {\n    let mut c = input.chars();\n    match c.next() {\n        None => String::new(),\n        Some(first) => first.to_uppercase().to_string() + c.as_str(),\n    }\n}\n\n// Step 2.\n// Apply the `capitalize_first` function to a slice of string slices.\n// Return a vector of strings.\n// [\"hello\", \"world\"] -> [\"Hello\", \"World\"]\npub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {\n    words.iter().map(|x| capitalize_first(x)).collect()\n}\n\n// Step 3.\n// Apply the `capitalize_first` function again to a slice of string slices.\n// Return a single string.\n// [\"hello\", \" \", \"world\"] -> \"Hello World\"\npub fn capitalize_words_string(words: &[&str]) -> String {\n    words.iter().map(|x| capitalize_first(x)).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_success() {\n        assert_eq!(capitalize_first(\"hello\"), \"Hello\");\n    }\n\n    #[test]\n    fn test_empty() {\n        assert_eq!(capitalize_first(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_iterate_string_vec() {\n        let words = vec![\"hello\", \"world\"];\n        assert_eq!(capitalize_words_vector(&words), [\"Hello\", \"World\"]);\n    }\n\n    #[test]\n    fn test_iterate_into_string() {\n        let words = vec![\"hello\", \" \", \"world\"];\n        assert_eq!(capitalize_words_string(&words), \"Hello World\");\n    }\n}\n"}

{"wrong_code": "// iterators4.rs\n// Execute `rustlings hint iterators4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\npub fn factorial(num: u64) -> u64 {\n    // Complete this function to return the factorial of num\n    // Do not use:\n    // - return\n    // Try not to use:\n    // - imperative style loops (for, while)\n    // - additional variables\n    // For an extra challenge, don't use:\n    // - recursion\n    // Execute `rustlings hint iterators4` for hints.\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn factorial_of_0() {\n        assert_eq!(1, factorial(0));\n    }\n\n    #[test]\n    fn factorial_of_1() {\n        assert_eq!(1, factorial(1));\n    }\n    #[test]\n    fn factorial_of_2() {\n        assert_eq!(2, factorial(2));\n    }\n\n    #[test]\n    fn factorial_of_4() {\n        assert_eq!(24, factorial(4));\n    }\n}\n", "error": "error[E0308]: mismatched types\n --> exercises/standard_library_types/iterators4.rs:6:31\n  |\n6 | pub fn factorial(num: u64) -> u64 {\n  |        ---------              ^^^ expected `u64`, found `()`\n  |        |\n  |        implicitly returns `()` as its body has no tail or `return` expression\n  |\nhelp: consider returning the local binding `num`\n  |\n6 ~ pub fn factorial(num: u64) -> u64 {\n7 +     num\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// iterators4.rs\n// Execute `rustlings hint iterators4` or use the `hint` watch subcommand for a hint.\n\n\npub fn factorial(num: u64) -> u64 {\n    // Complete this function to return the factorial of num\n    // Do not use:\n    // - return\n    // Try not to use:\n    // - imperative style loops (for, while)\n    // - additional variables\n    // For an extra challenge, don't use:\n    // - recursion\n    // Execute `rustlings hint iterators4` for hints.\n    (1..=num).fold(1, |a, e| a * e)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn factorial_of_0() {\n        assert_eq!(1, factorial(0));\n    }\n\n    #[test]\n    fn factorial_of_1() {\n        assert_eq!(1, factorial(1));\n    }\n    #[test]\n    fn factorial_of_2() {\n        assert_eq!(2, factorial(2));\n    }\n\n    #[test]\n    fn factorial_of_4() {\n        assert_eq!(24, factorial(4));\n    }\n}\n"}

{"wrong_code": "// box1.rs\n//\n// At compile time, Rust needs to know how much space a type takes up. This becomes problematic\n// for recursive types, where a value can have as part of itself another value of the same type.\n// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,\n// which also allows us to wrap a recursive type.\n//\n// The recursive type we're implementing in this exercise is the `cons list` - a data structure\n// frequently found in functional programming languages. Each item in a cons list contains two\n// elements: the value of the current item and the next item. The last item is a value called `Nil`.\n//\n// Step 1: use a `Box` in the enum definition to make the code compile\n// Step 2: create both empty and non-empty cons lists by replacing `todo!()`\n//\n// Note: the tests should not be changed\n//\n// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#[derive(PartialEq, Debug)]\npub enum List {\n    Cons(i32, List),\n    Nil,\n}\n\nfn main() {\n    println!(\"This is an empty cons list: {:?}\", create_empty_list());\n    println!(\n        \"This is a non-empty cons list: {:?}\",\n        create_non_empty_list()\n    );\n}\n\npub fn create_empty_list() -> List {\n    todo!()\n}\n\npub fn create_non_empty_list() -> List {\n    todo!()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_create_empty_list() {\n        assert_eq!(List::Nil, create_empty_list())\n    }\n\n    #[test]\n    fn test_create_non_empty_list() {\n        assert_ne!(create_empty_list(), create_non_empty_list())\n    }\n}\n", "error": "error[E0072]: recursive type `List` has infinite size\n  --> exercises/standard_library_types/box1.rs:22:1\n   |\n22 | pub enum List {\n   | ^^^^^^^^^^^^^\n23 |     Cons(i32, List),\n   |               ---- recursive without indirection\n   |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n   |\n23 |     Cons(i32, Box<List>),\n   |               ++++    +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0072`.\n", "right_code": "// box1.rs\n//\n// At compile time, Rust needs to know how much space a type takes up. This becomes problematic\n// for recursive types, where a value can have as part of itself another value of the same type.\n// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,\n// which also allows us to wrap a recursive type.\n//\n// The recursive type we're implementing in this exercise is the `cons list` - a data structure\n// frequently found in functional programming languages. Each item in a cons list contains two\n// elements: the value of the current item and the next item. The last item is a value called `Nil`.\n//\n// Step 1: use a `Box` in the enum definition to make the code compile\n// Step 2: create both empty and non-empty cons lists by replacing `todo!()`\n//\n// Note: the tests should not be changed\n//\n// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(PartialEq, Debug)]\npub enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nfn main() {\n    println!(\"This is an empty cons list: {:?}\", create_empty_list());\n    println!(\n        \"This is a non-empty cons list: {:?}\",\n        create_non_empty_list()\n    );\n}\n\npub fn create_empty_list() -> List {\n    List::Nil\n}\n\npub fn create_non_empty_list() -> List {\n    List::Cons(1, Box::new(List::Nil))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_create_empty_list() {\n        assert_eq!(List::Nil, create_empty_list())\n    }\n\n    #[test]\n    fn test_create_non_empty_list() {\n        assert_ne!(create_empty_list(), create_non_empty_list())\n    }\n}\n"}

{"wrong_code": "// arc1.rs\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values ranging\n// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]\n// We would like to use this set of numbers within 8 different threads simultaneously.\n// Each thread is going to get the sum of every eighth value, with an offset.\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n\n\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec<_> = (0..100u32).collect();\n    let shared_numbers = // TODO\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = // TODO\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n        }));\n    }\n    for handle in joinhandles.into_iter() {\n        handle.join().unwrap();\n    }\n}\n", "error": "error: expected expression, found `let` statement\n  --> exercises/standard_library_types/arc1.rs:30:5\n   |\n30 |     let mut joinhandles = Vec::new();\n   |     ^^^\n\nerror: `let` expressions are not supported here\n  --> exercises/standard_library_types/arc1.rs:30:5\n   |\n30 |     let mut joinhandles = Vec::new();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: only supported directly in conditions of `if` and `while` expressions\n\nerror[E0425]: cannot find value `child_numbers` in this scope\n  --> exercises/standard_library_types/arc1.rs:35:28\n   |\n35 |             let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n   |                            ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `shared_numbers`\n\nerror[E0658]: `let` expressions in this position are unstable\n  --> exercises/standard_library_types/arc1.rs:30:5\n   |\n30 |     let mut joinhandles = Vec::new();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n\nerror: unused import: `std::sync::Arc`\n  --> exercises/standard_library_types/arc1.rs:24:5\n   |\n24 | use std::sync::Arc;\n   |     ^^^^^^^^^^^^^^\n   |\nnote: the lint level is defined here\n  --> exercises/standard_library_types/arc1.rs:23:11\n   |\n23 | #![forbid(unused_imports)] // Do not change this, (or the next) line.\n   |           ^^^^^^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0658.\nFor more information about an error, try `rustc --explain E0425`.\n", "right_code": "// arc1.rs\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values ranging\n// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]\n// We would like to use this set of numbers within 8 different threads simultaneously.\n// Each thread is going to get the sum of every eighth value, with an offset.\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n\n\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec<_> = (0..100u32).collect();\n    let shared_numbers = Arc::new(numbers);// TODO\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = shared_numbers.clone();//; TODO\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n        }));\n    }\n    for handle in joinhandles.into_iter() {\n        handle.join().unwrap();\n    }\n}\n"}
{"wrong_code": "// arc1.rs\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values ranging\n// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]\n// We would like to use this set of numbers within 8 different threads simultaneously.\n// Each thread is going to get the sum of every eighth value, with an offset.\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n\n\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec<_> = (0..100u32).collect();\n    let shared_numbers = Arc::new(numbers)// TODO\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = shared_numbers.clone()// TODO\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n        }));\n    }\n    for handle in joinhandles.into_iter() {\n        handle.join().unwrap();\n    }\n}\n", "error": "error: expected `;`, found keyword `let`\n  --> exercises/standard_library_types/arc1.rs:29:43\n   |\n29 |     let shared_numbers = Arc::new(numbers)// TODO\n   |                                           ^ help: add `;` here\n30 |     let mut joinhandles = Vec::new();\n   |     --- unexpected token\n\nerror: expected `;`, found `joinhandles`\n  --> exercises/standard_library_types/arc1.rs:33:51\n   |\n33 |         let child_numbers = shared_numbers.clone()// TODO\n   |                                                   ^ help: add `;` here\n34 |         joinhandles.push(thread::spawn(move || {\n   |         ----------- unexpected token\n\nerror: aborting due to 2 previous errors\n\n", "right_code": "// arc1.rs\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values ranging\n// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]\n// We would like to use this set of numbers within 8 different threads simultaneously.\n// Each thread is going to get the sum of every eighth value, with an offset.\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n\n\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec<_> = (0..100u32).collect();\n    let shared_numbers = Arc::new(numbers);// TODO\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = shared_numbers.clone();//; TODO\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n        }));\n    }\n    for handle in joinhandles.into_iter() {\n        handle.join().unwrap();\n    }\n}\n"}
{"wrong_code": "// arc1.rs\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values ranging\n// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]\n// We would like to use this set of numbers within 8 different threads simultaneously.\n// Each thread is going to get the sum of every eighth value, with an offset.\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n\n\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec<_> = (0..100u32).collect();\n    let shared_numbers = Arc::new(numbers)// TODO\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = shared_numbers.clone();//; TODO\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n        }));\n    }\n    for handle in joinhandles.into_iter() {\n        handle.join().unwrap();\n    }\n}\n", "error": "error: expected `;`, found keyword `let`\n  --> exercises/standard_library_types/arc1.rs:28:43\n   |\n28 |     let shared_numbers = Arc::new(numbers)// TODO\n   |                                           ^ help: add `;` here\n29 |     let mut joinhandles = Vec::new();\n   |     --- unexpected token\n\nerror: aborting due to previous error\n\n", "right_code": "// arc1.rs\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values ranging\n// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]\n// We would like to use this set of numbers within 8 different threads simultaneously.\n// Each thread is going to get the sum of every eighth value, with an offset.\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n\n\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec<_> = (0..100u32).collect();\n    let shared_numbers = Arc::new(numbers);// TODO\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = shared_numbers.clone();//; TODO\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n        }));\n    }\n    for handle in joinhandles.into_iter() {\n        handle.join().unwrap();\n    }\n}\n"}

{"wrong_code": "// threads1.rs\n// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.\n// This program should wait until all the spawned threads have finished before exiting.\n\n// I AM NOT DONE\n\nuse std::thread;\nuse std::time::Duration;\n\n\nfn main() {\n\n    let mut handles = vec![];\n    for i in 0..10 {\n        thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            println!(\"thread {} is complete\", i);\n        });\n    }\n\n    let mut completed_threads = 0;\n    for handle in handles {\n        // TODO: a struct is returned from thread::spawn, can you use it?\n        completed_threads += 1;\n    }\n\n    if completed_threads != 10 {\n        panic!(\"Oh no! All the spawned threads did not finish!\");\n    }\n    \n}\n", "error": "error[E0282]: type annotations needed for `Vec<T>`\n  --> exercises/threads/threads1.rs:13:9\n   |\n13 |     let mut handles = vec![];\n   |         ^^^^^^^^^^^\n   |\nhelp: consider giving `handles` an explicit type, where the placeholders `_` are specified\n   |\n13 |     let mut handles: Vec<T> = vec![];\n   |                    ++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// threads1.rs\n// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.\n// This program should wait until all the spawned threads have finished before exiting.\n\n\nuse std::thread;\nuse std::time::Duration;\n\n\nfn main() {\n\n    let mut handles = vec![];\n    for i in 0..10 {\n        let t = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            println!(\"thread {} is complete\", i);\n        });\n        handles.push(t);\n    }\n\n    let mut completed_threads = 0;\n    for handle in handles {\n        // TODO: a struct is returned from thread::spawn, can you use it?\n        handle.join().unwrap();\n        completed_threads += 1;\n    }\n\n    if completed_threads != 10 {\n        panic!(\"Oh no! All the spawned threads did not finish!\");\n    }\n    \n}\n"}
{"wrong_code": "// threads1.rs\n// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.\n// This program should wait until all the spawned threads have finished before exiting.\n\n// I AM NOT DONE\n\nuse std::thread;\nuse std::time::Duration;\n\n\nfn main() {\n\n    let mut handles = vec![];\n    for i in 0..10 {\n        thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            println!(\"thread {} is complete\", i);\n        });\n    }\n\n    let mut completed_threads = 0;\n    for handle in handles {\n        // TODO: a struct is returned from thread::spawn, can you use it?\n        handle.join().unwrap();\n        completed_threads += 1;\n    }\n\n    if completed_threads != 10 {\n        panic!(\"Oh no! All the spawned threads did not finish!\");\n    }\n    \n}\n", "error": "error[E0282]: type annotations needed for `Vec<T>`\n  --> exercises/threads/threads1.rs:13:9\n   |\n13 |     let mut handles = vec![];\n   |         ^^^^^^^^^^^\n...\n24 |         handle.join().unwrap();\n   |         ------ type must be known at this point\n   |\nhelp: consider giving `handles` an explicit type, where the placeholders `_` are specified\n   |\n13 |     let mut handles: Vec<T> = vec![];\n   |                    ++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n", "right_code": "// threads1.rs\n// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.\n// This program should wait until all the spawned threads have finished before exiting.\n\n\nuse std::thread;\nuse std::time::Duration;\n\n\nfn main() {\n\n    let mut handles = vec![];\n    for i in 0..10 {\n        let t = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            println!(\"thread {} is complete\", i);\n        });\n        handles.push(t);\n    }\n\n    let mut completed_threads = 0;\n    for handle in handles {\n        // TODO: a struct is returned from thread::spawn, can you use it?\n        handle.join().unwrap();\n        completed_threads += 1;\n    }\n\n    if completed_threads != 10 {\n        panic!(\"Oh no! All the spawned threads did not finish!\");\n    }\n    \n}\n"}

{"wrong_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n// I AM NOT DONE\n\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(JobStatus { jobs_completed: 0 });\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            status_shared.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        println!(\"jobs completed {}\", ???);\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/threads/threads2.rs:32:39\n   |\n32 |         println!(\"jobs completed {}\", ???);\n   |                                       ^ expected expression\n\nerror: aborting due to previous error\n\n", "right_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n"}
{"wrong_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(JobStatus { jobs_completed: 0 });\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            status_shared.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        handle.join().unwrap();\n        println!(\"jobs completed {}\", ???);\n    }\n}\n", "error": "error: expected expression, found `?`\n  --> exercises/threads/threads2.rs:33:39\n   |\n33 |         println!(\"jobs completed {}\", ???);\n   |                                       ^ expected expression\n\nerror[E0599]: no method named `lock` found for struct `Arc<JobStatus>` in the current scope\n  --> exercises/threads/threads2.rs:23:45\n   |\n23 |             let mut counter = status_shared.lock().unwrap();\n   |                                             ^^^^ method not found in `Arc<JobStatus>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n"}
{"wrong_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(JobStatus { jobs_completed: 0 });\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            status_shared.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        handle.join().unwrap();\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n", "error": "error[E0599]: no method named `lock` found for struct `Arc<JobStatus>` in the current scope\n  --> exercises/threads/threads2.rs:23:45\n   |\n23 |             let mut counter = status_shared.lock().unwrap();\n   |                                             ^^^^ method not found in `Arc<JobStatus>`\n\nerror[E0599]: no method named `lock` found for struct `Arc<JobStatus>` in the current scope\n  --> exercises/threads/threads2.rs:33:46\n   |\n33 |         println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n   |                                              ^^^^ method not found in `Arc<JobStatus>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n"}
{"wrong_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(JobStatus { jobs_completed: 0 });\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        handle.join().unwrap();\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n", "error": "warning: unused import: `Mutex`\n --> exercises/threads/threads2.rs:7:22\n  |\n7 | use std::sync::{Arc, Mutex};\n  |                      ^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method named `lock` found for struct `Arc<JobStatus>` in the current scope\n  --> exercises/threads/threads2.rs:23:45\n   |\n23 |             let mut counter = status_shared.lock().unwrap();\n   |                                             ^^^^ method not found in `Arc<JobStatus>`\n\nerror[E0599]: no method named `lock` found for struct `Arc<JobStatus>` in the current scope\n  --> exercises/threads/threads2.rs:33:46\n   |\n33 |         println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n   |                                              ^^^^ method not found in `Arc<JobStatus>`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n", "right_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n"}
{"wrong_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        handle.join().unwrap();\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n", "error": "error[E0382]: use of moved value: `handle`\n    --> exercises/threads/threads2.rs:32:9\n     |\n28   |     for handle in handles {\n     |         ------ move occurs because `handle` has type `JoinHandle<()>`, which does not implement the `Copy` trait\n29   |         handle.join().unwrap();\n     |                ------ `handle` moved due to this method call\n...\n32   |         handle.join().unwrap();\n     |         ^^^^^^ value used here after move\n     |\nnote: this function takes ownership of the receiver `self`, which moves `handle`\n    --> /home/zoe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/mod.rs:1585:17\n     |\n1585 |     pub fn join(self) -> Result<T> {\n     |                 ^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// threads2.rs\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.\n// Building on the last exercise, we want all of the threads to complete their work but this time\n// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            // TODO: You must take an action before you update a shared value\n            let mut counter = status_shared.lock().unwrap();\n            counter.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything\n        // interesting in the output? Do you have to 'join' on all the handles?\n        println!(\"jobs completed {}\", status.lock().unwrap().jobs_completed);\n    }\n}\n"}

{"wrong_code": "// threads3.rs\n// Execute `rustlings hint threads3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nuse std::sync::mpsc;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct Queue {\n    length: u32,\n    first_half: Vec<u32>,\n    second_half: Vec<u32>,\n}\n\nimpl Queue {\n    fn new() -> Self {\n        Queue {\n            length: 10,\n            first_half: vec![1, 2, 3, 4, 5],\n            second_half: vec![6, 7, 8, 9, 10],\n        }\n    }\n}\n\nfn send_tx(q: Queue, tx: mpsc::Sender<u32>) -> () {\n    let qc = Arc::new(q);\n    let qc1 = Arc::clone(&qc);\n    let qc2 = Arc::clone(&qc);\n\n    thread::spawn(move || {\n        for val in &qc1.first_half {\n            println!(\"sending {:?}\", val);\n            tx.send(*val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        for val in &qc2.second_half {\n            println!(\"sending {:?}\", val);\n            tx.send(*val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n}\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let queue = Queue::new();\n    let queue_length = queue.length;\n\n    send_tx(queue, tx);\n\n    let mut total_received: u32 = 0;\n    for received in rx {\n        println!(\"Got: {}\", received);\n        total_received += 1;\n    }\n\n    println!(\"total numbers received: {}\", total_received);\n    assert_eq!(total_received, queue_length)\n}\n", "error": "error[E0382]: use of moved value: `tx`\n  --> exercises/threads/threads3.rs:40:19\n   |\n27 | fn send_tx(q: Queue, tx: mpsc::Sender<u32>) -> () {\n   |                      -- move occurs because `tx` has type `Sender<u32>`, which does not implement the `Copy` trait\n...\n32 |     thread::spawn(move || {\n   |                   ------- value moved into closure here\n...\n35 |             tx.send(*val).unwrap();\n   |             -- variable moved due to use in closure\n...\n40 |     thread::spawn(move || {\n   |                   ^^^^^^^ value used here after move\n...\n43 |             tx.send(*val).unwrap();\n   |             -- use occurs due to use in closure\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n", "right_code": "// threads3.rs\n// Execute `rustlings hint threads3` or use the `hint` watch subcommand for a hint.\n\n\nuse std::sync::mpsc;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct Queue {\n    length: u32,\n    first_half: Vec<u32>,\n    second_half: Vec<u32>,\n}\n\nimpl Queue {\n    fn new() -> Self {\n        Queue {\n            length: 10,\n            first_half: vec![1, 2, 3, 4, 5],\n            second_half: vec![6, 7, 8, 9, 10],\n        }\n    }\n}\n\nfn send_tx(q: Queue, tx: mpsc::Sender<u32>) -> () {\n    let qc = Arc::new(q);\n    let qc1 = Arc::clone(&qc);\n    let qc2 = Arc::clone(&qc);\n    let tx1 = tx.clone();\n    let tx2 = tx.clone();\n    thread::spawn(move || {\n        for val in &qc1.first_half {\n            println!(\"sending {:?}\", val);\n            tx1.send(*val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        for val in &qc2.second_half {\n            println!(\"sending {:?}\", val);\n            tx2.send(*val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n}\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let queue = Queue::new();\n    let queue_length = queue.length;\n\n    send_tx(queue, tx);\n\n    let mut total_received: u32 = 0;\n    for received in rx {\n        println!(\"Got: {}\", received);\n        total_received += 1;\n    }\n\n    println!(\"total numbers received: {}\", total_received);\n    assert_eq!(total_received, queue_length)\n}\n"}

{"wrong_code": "// macros1.rs\n// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmacro_rules! my_macro {\n    () => {\n        println!(\"Check out my macro!\");\n    };\n}\n\nfn main() {\n    my_macro();\n}\n", "error": "warning: unused macro definition: `my_macro`\n --> exercises/macros/macros1.rs:6:14\n  |\n6 | macro_rules! my_macro {\n  |              ^^^^^^^^\n  |\n  = note: `#[warn(unused_macros)]` on by default\n\nerror[E0425]: cannot find function `my_macro` in this scope\n  --> exercises/macros/macros1.rs:13:5\n   |\n13 |     my_macro();\n   |     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n", "right_code": "// macros1.rs\n// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.\n\n\nmacro_rules! my_macro {\n    () => {\n        println!(\"Check out my macro!\");\n    };\n}\n\nfn main() {\n    my_macro!();\n}\n"}

{"wrong_code": "// macros2.rs\n// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    my_macro!();\n}\n\nmacro_rules! my_macro {\n    () => {\n        println!(\"Check out my macro!\");\n    };\n}\n", "error": "error: cannot find macro `my_macro` in this scope\n --> exercises/macros/macros2.rs:7:5\n  |\n7 |     my_macro!();\n  |     ^^^^^^^^\n  |\n  = help: have you added the `#[macro_use]` on the module/import?\n\nwarning: unused macro definition: `my_macro`\n  --> exercises/macros/macros2.rs:10:14\n   |\n10 | macro_rules! my_macro {\n   |              ^^^^^^^^\n   |\n   = note: `#[warn(unused_macros)]` on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\n", "right_code": "// macros2.rs\n// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.\n\n\n\nmacro_rules! my_macro {\n    () => {\n        println!(\"Check out my macro!\");\n    };\n}\nfn main() {\n    my_macro!();\n}\n"}

{"wrong_code": "// macros3.rs\n// Make me compile, without taking the macro out of the module!\n// Execute `rustlings hint macros3` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmod macros {\n    macro_rules! my_macro {\n        () => {\n            println!(\"Check out my macro!\");\n        };\n    }\n}\n\nfn main() {\n    my_macro!();\n}\n", "error": "error: cannot find macro `my_macro` in this scope\n  --> exercises/macros/macros3.rs:16:5\n   |\n16 |     my_macro!();\n   |     ^^^^^^^^\n   |\n   = help: have you added the `#[macro_use]` on the module/import?\n\nwarning: unused macro definition: `my_macro`\n --> exercises/macros/macros3.rs:8:18\n  |\n8 |     macro_rules! my_macro {\n  |                  ^^^^^^^^\n  |\n  = note: `#[warn(unused_macros)]` on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\n", "right_code": "// macros3.rs\n// Make me compile, without taking the macro out of the module!\n// Execute `rustlings hint macros3` or use the `hint` watch subcommand for a hint.\n\n#[macro_use]\nmod macros {\n    macro_rules! my_macro {\n        () => {\n            println!(\"Check out my macro!\");\n        };\n    }\n}\n\nfn main() {\n    my_macro!();\n}\n"}

{"wrong_code": "// macros4.rs\n// Execute `rustlings hint macros4` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nmacro_rules! my_macro {\n    () => {\n        println!(\"Check out my macro!\");\n    }\n    ($val:expr) => {\n        println!(\"Look at this other macro: {}\", $val);\n    }\n}\n\nfn main() {\n    my_macro!();\n    my_macro!(7777);\n}\n", "error": "error: no rules expected the token `(`\n  --> exercises/macros/macros4.rs:10:5\n   |\n10 |     ($val:expr) => {\n   |     ^ no rules expected this token in macro call\n\nerror: aborting due to previous error\n\n", "right_code": "// macros4.rs\n// Execute `rustlings hint macros4` or use the `hint` watch subcommand for a hint.\n\n\nmacro_rules! my_macro {\n    () => {\n        println!(\"Check out my macro!\");\n    };\n    ($val:expr) => {\n        println!(\"Look at this other macro: {}\", $val);\n    }\n}\n\nfn main() {\n    my_macro!();\n    my_macro!(7777);\n}\n"}

{"wrong_code": "// clippy1.rs\n// The Clippy tool is a collection of lints to analyze your code\n// so you can catch common mistakes and improve your Rust code.\n//\n// For these exercises the code will fail to compile when there are clippy warnings\n// check clippy's suggestions from the output to solve the exercise.\n// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nuse std::f32;\n\nfn main() {\n    let pi = 3.14f32;\n    let radius = 5.00f32;\n\n    let area = pi * f32::powi(radius, 2);\n\n    println!(\n        \"The area of a circle with radius {:.2} is {:.5}!\",\n        radius, area\n    )\n}\n", "error": "    Checking clippy1 v0.0.1 (/home/zoe/rCore/rustlings-iKeepo/exercises/clippy)\nerror: approximate value of `f32::consts::PI` found\n  --> clippy1.rs:14:14\n   |\n14 |     let pi = 3.14f32;\n   |              ^^^^^^^\n   |\n   = help: consider using the constant directly\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n   = note: `#[deny(clippy::approx_constant)]` on by default\n\nerror: could not compile `clippy1` due to previous error\n", "right_code": "// clippy1.rs\n// The Clippy tool is a collection of lints to analyze your code\n// so you can catch common mistakes and improve your Rust code.\n//\n// For these exercises the code will fail to compile when there are clippy warnings\n// check clippy's suggestions from the output to solve the exercise.\n// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.\n\n\nuse std::f32;\n\nfn main() {\n    let pi = f32::consts::PI;\n    let radius = 5.00f32;\n\n    let area = pi * f32::powi(radius, 2);\n\n    println!(\n        \"The area of a circle with radius {:.2} is {:.5}!\",\n        radius, area\n    )\n}\n"}

{"wrong_code": "// clippy2.rs\n// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let mut res = 42;\n    let option = Some(12);\n    for x in option {\n        res += x;\n    }\n    println!(\"{}\", res);\n}\n", "error": "    Checking clippy2 v0.0.1 (/home/zoe/rCore/rustlings-iKeepo/exercises/clippy)\nerror: for loop over an `Option`. This is more readably written as an `if let` statement\n --> clippy2.rs:9:14\n  |\n9 |     for x in option {\n  |              ^^^^^^\n  |\n  = note: `-D for-loops-over-fallibles` implied by `-D warnings`\nhelp: to check pattern in a loop use `while let`\n  |\n9 |     while let Some(x) = option {\n  |     ~~~~~~~~~~~~~~~ ~~~\nhelp: consider using `if let` to clear intent\n  |\n9 |     if let Some(x) = option {\n  |     ~~~~~~~~~~~~ ~~~\n\nerror: could not compile `clippy2` due to previous error\n", "right_code": "// clippy2.rs\n// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.\n\n\nfn main() {\n    let mut res = 42;\n    let option = Some(12);\n    if let Some(x) = option {\n        res += x;\n    }\n    println!(\"{}\", res);\n}\n"}

{"wrong_code": "// clippy3.rs\n// Here's a couple more easy Clippy fixes, so you can see its utility.\n\n// I AM NOT DONE\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option<()> = None;\n    if my_option.is_none() {\n        my_option.unwrap();\n    }\n\n    let my_arr = &[\n        -1, -2, -3\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    value_a = value_b;\n    value_b = value_a;\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n", "error": "    Checking clippy3 v0.0.1 (/home/zoe/rCore/rustlings-iKeepo/exercises/clippy)\nerror: possibly missing a comma here\n  --> clippy3.rs:14:19\n   |\n14 |         -1, -2, -3\n   |                   ^\n   |\n   = note: to remove this lint, add a comma or write the expr in a single line\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n   = note: `#[deny(clippy::possible_missing_comma)]` on by default\n\nerror: this call to `unwrap()` will always panic\n  --> clippy3.rs:10:9\n   |\n9  |     if my_option.is_none() {\n   |        ------------------- because of this check\n10 |         my_option.unwrap();\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n   = note: `#[deny(clippy::panicking_unwrap)]` on by default\n\nerror: this looks like you are trying to swap `value_a` and `value_b`\n  --> clippy3.rs:25:5\n   |\n25 | /     value_a = value_b;\n26 | |     value_b = value_a;\n   | |_____________________^ help: try: `std::mem::swap(&mut value_a, &mut value_b)`\n   |\n   = note: or maybe you should use `std::mem::replace`?\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n   = note: `#[deny(clippy::almost_swapped)]` on by default\n\nerror: this let-binding has unit value\n  --> clippy3.rs:19:5\n   |\n19 |     let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `vec![1, 2, 3, 4, 5].resize(0, 5);`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n   = note: `-D clippy::let-unit-value` implied by `-D warnings`\n\nerror: could not compile `clippy3` due to 4 previous errors\n", "right_code": "// clippy3.rs\n// Here's a couple more easy Clippy fixes, so you can see its utility.\n\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option<()> = None;\n    if my_option.is_none() {\n        println!(\"What't in my_option is: {:#?}\", my_option);\n    }\n\n    let my_arr = &[\n        -1, -2, -3,\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let mut my_empty_vec = vec![1, 2, 3, 4, 5];\n    my_empty_vec.clear();\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    std::mem::swap(&mut value_a, &mut value_b);\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n"}
{"wrong_code": "// clippy3.rs\n// Here's a couple more easy Clippy fixes, so you can see its utility.\n\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option<()> = None;\n    if my_option.is_none() {\n        println!(\"What't in my_option is: {:#?}\", my_option);\n    }\n\n    let my_arr = &[\n        -1, -2, -3\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    value_a = value_b;\n    value_b = value_a;\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n", "error": "    Checking clippy3 v0.0.1 (/home/zoe/rCore/rustlings-iKeepo/exercises/clippy)\nerror: possibly missing a comma here\n  --> clippy3.rs:13:19\n   |\n13 |         -1, -2, -3\n   |                   ^\n   |\n   = note: to remove this lint, add a comma or write the expr in a single line\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n   = note: `#[deny(clippy::possible_missing_comma)]` on by default\n\nerror: this looks like you are trying to swap `value_a` and `value_b`\n  --> clippy3.rs:24:5\n   |\n24 | /     value_a = value_b;\n25 | |     value_b = value_a;\n   | |_____________________^ help: try: `std::mem::swap(&mut value_a, &mut value_b)`\n   |\n   = note: or maybe you should use `std::mem::replace`?\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n   = note: `#[deny(clippy::almost_swapped)]` on by default\n\nerror: this let-binding has unit value\n  --> clippy3.rs:18:5\n   |\n18 |     let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `vec![1, 2, 3, 4, 5].resize(0, 5);`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n   = note: `-D clippy::let-unit-value` implied by `-D warnings`\n\nerror: could not compile `clippy3` due to 3 previous errors\n", "right_code": "// clippy3.rs\n// Here's a couple more easy Clippy fixes, so you can see its utility.\n\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option<()> = None;\n    if my_option.is_none() {\n        println!(\"What't in my_option is: {:#?}\", my_option);\n    }\n\n    let my_arr = &[\n        -1, -2, -3,\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let mut my_empty_vec = vec![1, 2, 3, 4, 5];\n    my_empty_vec.clear();\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    std::mem::swap(&mut value_a, &mut value_b);\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n"}
{"wrong_code": "// clippy3.rs\n// Here's a couple more easy Clippy fixes, so you can see its utility.\n\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option<()> = None;\n    if my_option.is_none() {\n        println!(\"What't in my_option is: {:#?}\", my_option);\n    }\n\n    let my_arr = &[\n        -1, -2, -3,\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let my_empty_vec = vec![1, 2, 3, 4, 5];\n    my_empty_vec.clear();\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    value_a = value_b;\n    value_b = value_a;\n    std::mem::swap(&mut value_a, &mut value_b);\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n", "error": "    Checking clippy3 v0.0.1 (/home/zoe/rCore/rustlings-iKeepo/exercises/clippy)\nerror[E0596]: cannot borrow `my_empty_vec` as mutable, as it is not declared as mutable\n  --> clippy3.rs:19:5\n   |\n18 |     let my_empty_vec = vec![1, 2, 3, 4, 5];\n   |         ------------ help: consider changing this to be mutable: `mut my_empty_vec`\n19 |     my_empty_vec.clear();\n   |     ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `clippy3` due to previous error\n", "right_code": "// clippy3.rs\n// Here's a couple more easy Clippy fixes, so you can see its utility.\n\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option<()> = None;\n    if my_option.is_none() {\n        println!(\"What't in my_option is: {:#?}\", my_option);\n    }\n\n    let my_arr = &[\n        -1, -2, -3,\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let mut my_empty_vec = vec![1, 2, 3, 4, 5];\n    my_empty_vec.clear();\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    std::mem::swap(&mut value_a, &mut value_b);\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n"}

{"wrong_code": "// Type casting in Rust is done via the usage of the `as` operator.\n// Please note that the `as` operator is not only used when type casting.\n// It also helps with renaming imports.\n//\n// The goal is to make sure that the division does not fail to compile\n// and returns the proper type.\n// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.\n\n// I AM NOT DONE\n\nfn average(values: &[f64]) -> f64 {\n    let total = values.iter().sum::<f64>();\n    total / values.len()\n}\n\nfn main() {\n    let values = [3.5, 0.3, 13.0, 11.7];\n    println!(\"{}\", average(&values));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn returns_proper_type_and_value() {\n        assert_eq!(average(&[3.5, 0.3, 13.0, 11.7]), 7.125);\n    }\n}\n", "error": "error[E0277]: cannot divide `f64` by `usize`\n  --> exercises/conversions/using_as.rs:13:11\n   |\n13 |     total / values.len()\n   |           ^ no implementation for `f64 / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented for `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n", "right_code": "// Type casting in Rust is done via the usage of the `as` operator.\n// Please note that the `as` operator is not only used when type casting.\n// It also helps with renaming imports.\n//\n// The goal is to make sure that the division does not fail to compile\n// and returns the proper type.\n// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.\n\n\nfn average(values: &[f64]) -> f64 {\n    let total = values.iter().sum::<f64>();\n    total / values.len() as f64\n}\n\nfn main() {\n    let values = [3.5, 0.3, 13.0, 11.7];\n    println!(\"{}\", average(&values));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn returns_proper_type_and_value() {\n        assert_eq!(average(&[3.5, 0.3, 13.0, 11.7]), 7.125);\n    }\n}\n"}

{"wrong_code": "// The From trait is used for value-to-value conversions.\n// If From is implemented correctly for a type, the Into trait should work conversely.\n// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html\n// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.\n\n#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: usize,\n}\n\n// We implement the Default trait to use it as a fallback\n// when the provided string is not convertible into a Person object\nimpl Default for Person {\n    fn default() -> Person {\n        Person {\n            name: String::from(\"John\"),\n            age: 30,\n        }\n    }\n}\n\n// Your task is to complete this implementation\n// in order for the line `let p = Person::from(\"Mark,20\")` to compile\n// Please note that you'll need to parse the age component into a `usize`\n// with something like `\"4\".parse::<usize>()`. The outcome of this needs to\n// be handled appropriately.\n//\n// Steps:\n// 1. If the length of the provided string is 0, then return the default of Person\n// 2. Split the given string on the commas present in it\n// 3. Extract the first element from the split operation and use it as the name\n// 4. If the name is empty, then return the default of Person\n// 5. Extract the other element from the split operation and parse it into a `usize` as the age\n// If while parsing the age, something goes wrong, then return the default of Person\n// Otherwise, then return an instantiated Person object with the results\n\n// I AM NOT DONE\n\nimpl From<&str> for Person {\n    fn from(s: &str) -> Person {\n    }\n}\n\nfn main() {\n    // Use the `from` function\n    let p1 = Person::from(\"Mark,20\");\n    // Since From is implemented for Person, we should be able to use Into\n    let p2: Person = \"Gerald,70\".into();\n    println!(\"{:?}\", p1);\n    println!(\"{:?}\", p2);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_default() {\n        // Test that the default person is 30 year old John\n        let dp = Person::default();\n        assert_eq!(dp.name, \"John\");\n        assert_eq!(dp.age, 30);\n    }\n    #[test]\n    fn test_bad_convert() {\n        // Test that John is returned when bad string is provided\n        let p = Person::from(\"\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n    #[test]\n    fn test_good_convert() {\n        // Test that \"Mark,20\" works\n        let p = Person::from(\"Mark,20\");\n        assert_eq!(p.name, \"Mark\");\n        assert_eq!(p.age, 20);\n    }\n    #[test]\n    fn test_bad_age() {\n        // Test that \"Mark,twenty\" will return the default person due to an error in parsing age\n        let p = Person::from(\"Mark,twenty\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_comma_and_age() {\n        let p: Person = Person::from(\"Mark\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_age() {\n        let p: Person = Person::from(\"Mark,\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name() {\n        let p: Person = Person::from(\",1\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name_and_age() {\n        let p: Person = Person::from(\",\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name_and_invalid_age() {\n        let p: Person = Person::from(\",one\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_trailing_comma() {\n        let p: Person = Person::from(\"Mike,32,\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_trailing_comma_and_some_string() {\n        let p: Person = Person::from(\"Mike,32,man\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/conversions/from_into.rs:41:25\n   |\n41 |     fn from(s: &str) -> Person {\n   |        ----             ^^^^^^ expected struct `Person`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// The From trait is used for value-to-value conversions.\n// If From is implemented correctly for a type, the Into trait should work conversely.\n// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html\n// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.\n\n#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: usize,\n}\n\n// We implement the Default trait to use it as a fallback\n// when the provided string is not convertible into a Person object\nimpl Default for Person {\n    fn default() -> Person {\n        Person {\n            name: String::from(\"John\"),\n            age: 30,\n        }\n    }\n}\n\n// Your task is to complete this implementation\n// in order for the line `let p = Person::from(\"Mark,20\")` to compile\n// Please note that you'll need to parse the age component into a `usize`\n// with something like `\"4\".parse::<usize>()`. The outcome of this needs to\n// be handled appropriately.\n//\n// Steps:\n// 1. If the length of the provided string is 0, then return the default of Person\n// 2. Split the given string on the commas present in it\n// 3. Extract the first element from the split operation and use it as the name\n// 4. If the name is empty, then return the default of Person\n// 5. Extract the other element from the split operation and parse it into a `usize` as the age\n// If while parsing the age, something goes wrong, then return the default of Person\n// Otherwise, then return an instantiated Person object with the results\n\n\nimpl From<&str> for Person {\n    fn from(s: &str) -> Person {\n        match s.split_once(',') {\n            Some((first, second)) => {\n                if first.is_empty() {\n                    Person::default()\n                }else if let Ok(x) = second.parse::<usize>() {\n                    Person{\n                        name: first.to_string(),\n                        age: x\n                    }\n                }else{\n                    Person::default()\n                }\n            }\n            _ => Person::default(),\n        }\n    }\n}\nfn main() {\n    // Use the `from` function\n    let p1 = Person::from(\"Mark,20\");\n    // Since From is implemented for Person, we should be able to use Into\n    let p2: Person = \"Gerald,70\".into();\n    println!(\"{:?}\", p1);\n    println!(\"{:?}\", p2);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_default() {\n        // Test that the default person is 30 year old John\n        let dp = Person::default();\n        assert_eq!(dp.name, \"John\");\n        assert_eq!(dp.age, 30);\n    }\n    #[test]\n    fn test_bad_convert() {\n        // Test that John is returned when bad string is provided\n        let p = Person::from(\"\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n    #[test]\n    fn test_good_convert() {\n        // Test that \"Mark,20\" works\n        let p = Person::from(\"Mark,20\");\n        assert_eq!(p.name, \"Mark\");\n        assert_eq!(p.age, 20);\n    }\n    #[test]\n    fn test_bad_age() {\n        // Test that \"Mark,twenty\" will return the default person due to an error in parsing age\n        let p = Person::from(\"Mark,twenty\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_comma_and_age() {\n        let p: Person = Person::from(\"Mark\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_age() {\n        let p: Person = Person::from(\"Mark,\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name() {\n        let p: Person = Person::from(\",1\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name_and_age() {\n        let p: Person = Person::from(\",\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name_and_invalid_age() {\n        let p: Person = Person::from(\",one\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_trailing_comma() {\n        let p: Person = Person::from(\"Mike,32,\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_trailing_comma_and_some_string() {\n        let p: Person = Person::from(\"Mike,32,man\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n}\n"}

{"wrong_code": "// from_str.rs\n// This is similar to from_into.rs, but this time we'll implement `FromStr`\n// and return errors instead of falling back to a default value.\n// Additionally, upon implementing FromStr, you can use the `parse` method\n// on strings to generate an object of the implementor type.\n// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html\n// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.\n\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nstruct Person {\n    name: String,\n    age: usize,\n}\n\n// We will use this error type for the `FromStr` implementation.\n#[derive(Debug, PartialEq)]\nenum ParsePersonError {\n    // Empty input string\n    Empty,\n    // Incorrect number of fields\n    BadLen,\n    // Empty name field\n    NoName,\n    // Wrapped error from parse::<usize>()\n    ParseInt(ParseIntError),\n}\n\n// I AM NOT DONE\n\n// Steps:\n// 1. If the length of the provided string is 0, an error should be returned\n// 2. Split the given string on the commas present in it\n// 3. Only 2 elements should be returned from the split, otherwise return an error\n// 4. Extract the first element from the split operation and use it as the name\n// 5. Extract the other element from the split operation and parse it into a `usize` as the age\n//    with something like `\"4\".parse::<usize>()`\n// 6. If while extracting the name and the age something goes wrong, an error should be returned\n// If everything goes well, then return a Result of a Person object\n//\n// As an aside: `Box<dyn Error>` implements `From<&'_ str>`. This means that if you want to return a\n// string error message, you can do so via just using return `Err(\"my error message\".into())`.\n\nimpl FromStr for Person {\n    type Err = ParsePersonError;\n    fn from_str(s: &str) -> Result<Person, Self::Err> {\n    }\n}\n\nfn main() {\n    let p = \"Mark,20\".parse::<Person>().unwrap();\n    println!(\"{:?}\", p);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn empty_input() {\n        assert_eq!(\"\".parse::<Person>(), Err(ParsePersonError::Empty));\n    }\n    #[test]\n    fn good_input() {\n        let p = \"John,32\".parse::<Person>();\n        assert!(p.is_ok());\n        let p = p.unwrap();\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 32);\n    }\n    #[test]\n    fn missing_age() {\n        assert!(matches!(\n            \"John,\".parse::<Person>(),\n            Err(ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn invalid_age() {\n        assert!(matches!(\n            \"John,twenty\".parse::<Person>(),\n            Err(ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn missing_comma_and_age() {\n        assert_eq!(\"John\".parse::<Person>(), Err(ParsePersonError::BadLen));\n    }\n\n    #[test]\n    fn missing_name() {\n        assert_eq!(\",1\".parse::<Person>(), Err(ParsePersonError::NoName));\n    }\n\n    #[test]\n    fn missing_name_and_age() {\n        assert!(matches!(\n            \",\".parse::<Person>(),\n            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn missing_name_and_invalid_age() {\n        assert!(matches!(\n            \",one\".parse::<Person>(),\n            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn trailing_comma() {\n        assert_eq!(\"John,32,\".parse::<Person>(), Err(ParsePersonError::BadLen));\n    }\n\n    #[test]\n    fn trailing_comma_and_some_string() {\n        assert_eq!(\n            \"John,32,man\".parse::<Person>(),\n            Err(ParsePersonError::BadLen)\n        );\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/conversions/from_str.rs:48:29\n   |\n48 |     fn from_str(s: &str) -> Result<Person, Self::Err> {\n   |        --------             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note:   expected enum `Result<Person, ParsePersonError>`\n           found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// from_str.rs\n// This is similar to from_into.rs, but this time we'll implement `FromStr`\n// and return errors instead of falling back to a default value.\n// Additionally, upon implementing FromStr, you can use the `parse` method\n// on strings to generate an object of the implementor type.\n// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html\n// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.\n\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nstruct Person {\n    name: String,\n    age: usize,\n}\n\n// We will use this error type for the `FromStr` implementation.\n#[derive(Debug, PartialEq)]\nenum ParsePersonError {\n    // Empty input string\n    Empty,\n    // Incorrect number of fields\n    BadLen,\n    // Empty name field\n    NoName,\n    // Wrapped error from parse::<usize>()\n    ParseInt(ParseIntError),\n}\n\n\n// Steps:\n// 1. If the length of the provided string is 0, an error should be returned\n// 2. Split the given string on the commas present in it\n// 3. Only 2 elements should be returned from the split, otherwise return an error\n// 4. Extract the first element from the split operation and use it as the name\n// 5. Extract the other element from the split operation and parse it into a `usize` as the age\n//    with something like `\"4\".parse::<usize>()`\n// 6. If while extracting the name and the age something goes wrong, an error should be returned\n// If everything goes well, then return a Result of a Person object\n//\n// As an aside: `Box<dyn Error>` implements `From<&'_ str>`. This means that if you want to return a\n// string error message, you can do so via just using return `Err(\"my error message\".into())`.\n\nimpl FromStr for Person {\n    type Err = ParsePersonError;\n    fn from_str(s: &str) -> Result<Person, Self::Err> {\n        if s.is_empty() {\n            Err(Self::Err::Empty)\n        } else {\n            let p: Vec<&str> = s.split(',').collect();\n            if p.len() != 2 {\n                Err(Self::Err::BadLen)\n            } else if p[0].len() == 0 {\n                Err(Self::Err::NoName)\n            } else {\n                match p[1].parse::<usize>() {\n                    Ok(a) => Ok(Person { name: p[0].to_string(), age: a }),\n                    Err(a) => Err(Self::Err::ParseInt(a)),\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let p = \"Mark,20\".parse::<Person>().unwrap();\n    println!(\"{:?}\", p);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn empty_input() {\n        assert_eq!(\"\".parse::<Person>(), Err(ParsePersonError::Empty));\n    }\n    #[test]\n    fn good_input() {\n        let p = \"John,32\".parse::<Person>();\n        assert!(p.is_ok());\n        let p = p.unwrap();\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 32);\n    }\n    #[test]\n    fn missing_age() {\n        assert!(matches!(\n            \"John,\".parse::<Person>(),\n            Err(ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn invalid_age() {\n        assert!(matches!(\n            \"John,twenty\".parse::<Person>(),\n            Err(ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn missing_comma_and_age() {\n        assert_eq!(\"John\".parse::<Person>(), Err(ParsePersonError::BadLen));\n    }\n\n    #[test]\n    fn missing_name() {\n        assert_eq!(\",1\".parse::<Person>(), Err(ParsePersonError::NoName));\n    }\n\n    #[test]\n    fn missing_name_and_age() {\n        assert!(matches!(\n            \",\".parse::<Person>(),\n            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn missing_name_and_invalid_age() {\n        assert!(matches!(\n            \",one\".parse::<Person>(),\n            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn trailing_comma() {\n        assert_eq!(\"John,32,\".parse::<Person>(), Err(ParsePersonError::BadLen));\n    }\n\n    #[test]\n    fn trailing_comma_and_some_string() {\n        assert_eq!(\n            \"John,32,man\".parse::<Person>(),\n            Err(ParsePersonError::BadLen)\n        );\n    }\n}\n"}

{"wrong_code": "// try_from_into.rs\n// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.\n// Basically, this is the same as From. The main difference is that this should return a Result type\n// instead of the target type itself.\n// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html\n// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.\n\nuse std::convert::{TryFrom, TryInto};\n\n#[derive(Debug, PartialEq)]\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n// We will use this error type for these `TryFrom` conversions.\n#[derive(Debug, PartialEq)]\nenum IntoColorError {\n    // Incorrect length of slice\n    BadLen,\n    // Integer conversion error\n    IntConversion,\n}\n\n// I AM NOT DONE\n\n// Your task is to complete this implementation\n// and return an Ok result of inner type Color.\n// You need to create an implementation for a tuple of three integers,\n// an array of three integers, and a slice of integers.\n//\n// Note that the implementation for tuple and array will be checked at compile time,\n// but the slice implementation needs to check the slice length!\n// Also note that correct RGB color values must be integers in the 0..=255 range.\n\n// Tuple implementation\nimpl TryFrom<(i16, i16, i16)> for Color {\n    type Error = IntoColorError;\n    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {\n    }\n}\n\n// Array implementation\nimpl TryFrom<[i16; 3]> for Color {\n    type Error = IntoColorError;\n    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {\n    }\n}\n\n// Slice implementation\nimpl TryFrom<&[i16]> for Color {\n    type Error = IntoColorError;\n    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {\n    }\n}\n\nfn main() {\n    // Use the `try_from` function\n    let c1 = Color::try_from((183, 65, 14));\n    println!(\"{:?}\", c1);\n\n    // Since TryFrom is implemented for Color, we should be able to use TryInto\n    let c2: Result<Color, _> = [183, 65, 14].try_into();\n    println!(\"{:?}\", c2);\n\n    let v = vec![183, 65, 14];\n    // With slice we should use `try_from` function\n    let c3 = Color::try_from(&v[..]);\n    println!(\"{:?}\", c3);\n    // or take slice within round brackets and use TryInto\n    let c4: Result<Color, _> = (&v[..]).try_into();\n    println!(\"{:?}\", c4);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_tuple_out_of_range_positive() {\n        assert_eq!(\n            Color::try_from((256, 1000, 10000)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_out_of_range_negative() {\n        assert_eq!(\n            Color::try_from((-1, -10, -256)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_sum() {\n        assert_eq!(\n            Color::try_from((-1, 255, 255)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_correct() {\n        let c: Result<Color, _> = (183, 65, 14).try_into();\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_array_out_of_range_positive() {\n        let c: Result<Color, _> = [1000, 10000, 256].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_out_of_range_negative() {\n        let c: Result<Color, _> = [-10, -256, -1].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_sum() {\n        let c: Result<Color, _> = [-1, 255, 255].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_correct() {\n        let c: Result<Color, _> = [183, 65, 14].try_into();\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_slice_out_of_range_positive() {\n        let arr = [10000, 256, 1000];\n        assert_eq!(\n            Color::try_from(&arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_out_of_range_negative() {\n        let arr = [-256, -1, -10];\n        assert_eq!(\n            Color::try_from(&arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_sum() {\n        let arr = [-1, 255, 255];\n        assert_eq!(\n            Color::try_from(&arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_correct() {\n        let v = vec![183, 65, 14];\n        let c: Result<Color, _> = Color::try_from(&v[..]);\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_slice_excess_length() {\n        let v = vec![0, 0, 0, 0];\n        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));\n    }\n    #[test]\n    fn test_slice_insufficient_length() {\n        let v = vec![0, 0];\n        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));\n    }\n}\n", "error": "error[E0308]: mismatched types\n  --> exercises/conversions/try_from_into.rs:40:44\n   |\n40 |     fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {\n   |        --------                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note:   expected enum `Result<Color, IntoColorError>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> exercises/conversions/try_from_into.rs:47:35\n   |\n47 |     fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {\n   |        --------                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note:   expected enum `Result<Color, IntoColorError>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> exercises/conversions/try_from_into.rs:54:35\n   |\n54 |     fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {\n   |        --------                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`\n   |        |\n   |        implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note:   expected enum `Result<Color, IntoColorError>`\n           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n", "right_code": "// try_from_into.rs\n// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.\n// Basically, this is the same as From. The main difference is that this should return a Result type\n// instead of the target type itself.\n// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html\n// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.\n\nuse std::convert::{TryFrom, TryInto};\n\n#[derive(Debug, PartialEq)]\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n// We will use this error type for these `TryFrom` conversions.\n#[derive(Debug, PartialEq)]\nenum IntoColorError {\n    // Incorrect length of slice\n    BadLen,\n    // Integer conversion error\n    IntConversion,\n}\n\n\n// Your task is to complete this implementation\n// and return an Ok result of inner type Color.\n// You need to create an implementation for a tuple of three integers,\n// an array of three integers, and a slice of integers.\n//\n// Note that the implementation for tuple and array will be checked at compile time,\n// but the slice implementation needs to check the slice length!\n// Also note that correct RGB color values must be integers in the 0..=255 range.\n\n// Tuple implementation\nimpl TryFrom<(i16, i16, i16)> for Color {\n    type Error = IntoColorError;\n    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {\n        for i in [tuple.0, tuple.1, tuple.2] {\n            if i < 0 || i > 255 {\n                return Err(IntoColorError::IntConversion)\n            }\n        }\n        Ok(Color{red: tuple.0 as u8, green: tuple.1 as u8, blue: tuple.2 as u8})\n    }\n}\n\n// Array implementation\nimpl TryFrom<[i16; 3]> for Color {\n    type Error = IntoColorError;\n    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {\n        Self::try_from((arr[0], arr[1], arr[2]))\n    }\n}\n\n// Slice implementation\nimpl TryFrom<&[i16]> for Color {\n    type Error = IntoColorError;\n    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {\n        if slice.len() != 3 {\n            Err(IntoColorError::BadLen)\n        } else {\n            Self::try_from((slice[0], slice[1], slice[2]))\n        }\n    }\n}\n\nfn main() {\n    // Use the `try_from` function\n    let c1 = Color::try_from((183, 65, 14));\n    println!(\"{:?}\", c1);\n\n    // Since TryFrom is implemented for Color, we should be able to use TryInto\n    let c2: Result<Color, _> = [183, 65, 14].try_into();\n    println!(\"{:?}\", c2);\n\n    let v = vec![183, 65, 14];\n    // With slice we should use `try_from` function\n    let c3 = Color::try_from(&v[..]);\n    println!(\"{:?}\", c3);\n    // or take slice within round brackets and use TryInto\n    let c4: Result<Color, _> = (&v[..]).try_into();\n    println!(\"{:?}\", c4);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_tuple_out_of_range_positive() {\n        assert_eq!(\n            Color::try_from((256, 1000, 10000)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_out_of_range_negative() {\n        assert_eq!(\n            Color::try_from((-1, -10, -256)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_sum() {\n        assert_eq!(\n            Color::try_from((-1, 255, 255)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_correct() {\n        let c: Result<Color, _> = (183, 65, 14).try_into();\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_array_out_of_range_positive() {\n        let c: Result<Color, _> = [1000, 10000, 256].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_out_of_range_negative() {\n        let c: Result<Color, _> = [-10, -256, -1].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_sum() {\n        let c: Result<Color, _> = [-1, 255, 255].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_correct() {\n        let c: Result<Color, _> = [183, 65, 14].try_into();\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_slice_out_of_range_positive() {\n        let arr = [10000, 256, 1000];\n        assert_eq!(\n            Color::try_from(&arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_out_of_range_negative() {\n        let arr = [-256, -1, -10];\n        assert_eq!(\n            Color::try_from(&arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_sum() {\n        let arr = [-1, 255, 255];\n        assert_eq!(\n            Color::try_from(&arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_correct() {\n        let v = vec![183, 65, 14];\n        let c: Result<Color, _> = Color::try_from(&v[..]);\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_slice_excess_length() {\n        let v = vec![0, 0, 0, 0];\n        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));\n    }\n    #[test]\n    fn test_slice_insufficient_length() {\n        let v = vec![0, 0];\n        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));\n    }\n}\n"}

